{"kind":"JsonApi","prelude":{"crate_name":"num_traits","crate_root":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src","external_crates":[{"name":"alloc","num":5,"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/lib.rs"},{"name":"libc","num":7,"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/lib.rs"},{"name":"std","num":1,"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/lib.rs"},{"name":"collections","num":3,"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/lib.rs"},{"name":"compiler_builtins","num":9,"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/lib.rs"},{"name":"panic_unwind","num":11,"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/lib.rs"},{"name":"rustc_unicode","num":4,"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/lib.rs"},{"name":"rand","num":6,"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/lib.rs"},{"name":"core","num":2,"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/lib.rs"},{"name":"unwind","num":8,"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/lib.rs"},{"name":"alloc_jemalloc","num":10,"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/lib.rs"}],"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/lib.rs","byte_start":472,"byte_end":9542,"line_start":11,"line_end":236,"column_start":1,"column_end":1}},"imports":[{"kind":"Use","id":{"krate":0,"index":5},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/lib.rs","byte_start":574,"byte_end":581,"line_start":15,"line_end":15,"column_start":17,"column_end":24},"name":"Bounded","value":""},{"kind":"GlobUse","id":{"krate":0,"index":8},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/lib.rs","byte_start":685,"byte_end":686,"line_start":18,"line_end":18,"column_start":23,"column_end":24},"name":"*","value":"CheckedMul"},{"kind":"Use","id":{"krate":0,"index":9},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/lib.rs","byte_start":713,"byte_end":723,"line_start":19,"line_end":19,"column_start":26,"column_end":36},"name":"Saturating","value":""},{"kind":"GlobUse","id":{"krate":0,"index":11},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/lib.rs","byte_start":795,"byte_end":796,"line_start":21,"line_end":21,"column_start":15,"column_end":16},"name":"*","value":"NumCast"},{"kind":"Use","id":{"krate":0,"index":12},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/lib.rs","byte_start":811,"byte_end":818,"line_start":22,"line_end":22,"column_start":14,"column_end":21},"name":"PrimInt","value":""}],"defs":[{"kind":"Mod","id":{"krate":0,"index":14},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/lib.rs","byte_start":862,"byte_end":872,"line_start":25,"line_end":25,"column_start":9,"column_end":19},"name":"identities","qualname":"::identities","value":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/identities.rs","parent":null,"children":[{"krate":0,"index":15},{"krate":0,"index":16},{"krate":0,"index":372},{"krate":0,"index":376},{"krate":0,"index":380},{"krate":0,"index":384},{"krate":0,"index":388},{"krate":0,"index":392},{"krate":0,"index":396},{"krate":0,"index":400},{"krate":0,"index":404},{"krate":0,"index":408},{"krate":0,"index":412},{"krate":0,"index":416},{"krate":0,"index":20},{"krate":0,"index":420},{"krate":0,"index":422},{"krate":0,"index":424},{"krate":0,"index":426},{"krate":0,"index":428},{"krate":0,"index":430},{"krate":0,"index":432},{"krate":0,"index":434},{"krate":0,"index":436},{"krate":0,"index":438},{"krate":0,"index":440},{"krate":0,"index":442},{"krate":0,"index":22},{"krate":0,"index":24}],"decl_id":null,"docs":""},{"kind":"Trait","id":{"krate":0,"index":16},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/identities.rs","byte_start":9635,"byte_end":9639,"line_start":4,"line_end":4,"column_start":11,"column_end":15},"name":"Zero","qualname":"::identities::Zero","value":"Zero:  Sized + Add<Self, Output = Self>","parent":null,"children":[{"krate":0,"index":17},{"krate":0,"index":18}],"decl_id":null,"docs":" Defines an additive identity element for `Self`.\n"},{"kind":"Method","id":{"krate":0,"index":17},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/identities.rs","byte_start":10151,"byte_end":10155,"line_start":20,"line_end":20,"column_start":8,"column_end":12},"name":"zero","qualname":"::identities::Zero::zero","value":"fn () -> Self","parent":{"krate":0,"index":16},"children":[],"decl_id":null,"docs":" Returns the additive identity element of `Self`, `0`.\n\n # Laws\n\n ```{.text}\n a + 0 = a       ∀ a ∈ Self\n 0 + a = a       ∀ a ∈ Self\n ```\n\n # Purity\n\n This function should return the same result at all times regardless of\n external mutable state, for example values stored in TLS or in\n `static mut`s.\n"},{"kind":"Method","id":{"krate":0,"index":18},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/identities.rs","byte_start":10257,"byte_end":10264,"line_start":24,"line_end":24,"column_start":8,"column_end":15},"name":"is_zero","qualname":"::identities::Zero::is_zero","value":"fn (&self) -> bool","parent":{"krate":0,"index":16},"children":[],"decl_id":null,"docs":" Returns `true` if `self` is equal to the additive identity.\n"},{"kind":"Macro","id":{"krate":4294967295,"index":4294967295},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/identities.rs","byte_start":10297,"byte_end":10306,"line_start":27,"line_end":27,"column_start":14,"column_end":23},"name":"zero_impl","qualname":"zero_impl::7387985140056112285","value":"","parent":null,"children":[],"decl_id":null,"docs":""},{"kind":"Trait","id":{"krate":0,"index":20},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/identities.rs","byte_start":10887,"byte_end":10890,"line_start":54,"line_end":54,"column_start":11,"column_end":14},"name":"One","qualname":"::identities::One","value":"One:  Sized + Mul<Self, Output = Self>","parent":null,"children":[{"krate":0,"index":21}],"decl_id":null,"docs":" Defines a multiplicative identity element for `Self`.\n"},{"kind":"Method","id":{"krate":0,"index":21},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/identities.rs","byte_start":11408,"byte_end":11411,"line_start":70,"line_end":70,"column_start":8,"column_end":11},"name":"one","qualname":"::identities::One::one","value":"fn () -> Self","parent":{"krate":0,"index":20},"children":[],"decl_id":null,"docs":" Returns the multiplicative identity element of `Self`, `1`.\n\n # Laws\n\n ```{.text}\n a * 1 = a       ∀ a ∈ Self\n 1 * a = a       ∀ a ∈ Self\n ```\n\n # Purity\n\n This function should return the same result at all times regardless of\n external mutable state, for example values stored in TLS or in\n `static mut`s.\n"},{"kind":"Macro","id":{"krate":4294967295,"index":4294967295},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/identities.rs","byte_start":11439,"byte_end":11447,"line_start":73,"line_end":73,"column_start":14,"column_end":22},"name":"one_impl","qualname":"one_impl::6343101134656279701","value":"","parent":null,"children":[],"decl_id":null,"docs":""},{"kind":"Function","id":{"krate":0,"index":22},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/identities.rs","byte_start":12000,"byte_end":12004,"line_start":101,"line_end":101,"column_start":26,"column_end":30},"name":"zero","qualname":"::identities::zero","value":"fn <T> () -> T","parent":null,"children":[],"decl_id":null,"docs":" Returns the additive identity, `0`.\n"},{"kind":"Function","id":{"krate":0,"index":24},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/identities.rs","byte_start":12110,"byte_end":12113,"line_start":104,"line_end":104,"column_start":26,"column_end":29},"name":"one","qualname":"::identities::one","value":"fn <T> () -> T","parent":null,"children":[],"decl_id":null,"docs":" Returns the multiplicative identity, `1`.\n"},{"kind":"Mod","id":{"krate":0,"index":26},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/lib.rs","byte_start":882,"byte_end":886,"line_start":26,"line_end":26,"column_start":9,"column_end":13},"name":"sign","qualname":"::sign","value":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/sign.rs","parent":null,"children":[{"krate":0,"index":27},{"krate":0,"index":28},{"krate":0,"index":29},{"krate":0,"index":30},{"krate":0,"index":444},{"krate":0,"index":457},{"krate":0,"index":470},{"krate":0,"index":483},{"krate":0,"index":496},{"krate":0,"index":509},{"krate":0,"index":521},{"krate":0,"index":42},{"krate":0,"index":45},{"krate":0,"index":49},{"krate":0,"index":52},{"krate":0,"index":533},{"krate":0,"index":534},{"krate":0,"index":535},{"krate":0,"index":536},{"krate":0,"index":537}],"decl_id":null,"docs":""},{"kind":"Trait","id":{"krate":0,"index":30},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/sign.rs","byte_start":12283,"byte_end":12289,"line_start":7,"line_end":7,"column_start":11,"column_end":17},"name":"Signed","qualname":"::sign::Signed","value":"Signed:  Sized + Num + Neg<Output = Self>","parent":null,"children":[{"krate":0,"index":31},{"krate":0,"index":33},{"krate":0,"index":36},{"krate":0,"index":38},{"krate":0,"index":40}],"decl_id":null,"docs":" Useful functions for signed numbers (i.e. numbers that can be negative).\n"},{"kind":"Method","id":{"krate":0,"index":31},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/sign.rs","byte_start":12542,"byte_end":12545,"line_start":13,"line_end":13,"column_start":8,"column_end":11},"name":"abs","qualname":"::sign::Signed::abs","value":"fn (&self) -> Self","parent":{"krate":0,"index":30},"children":[],"decl_id":null,"docs":" Computes the absolute value.\n\n For `f32` and `f64`, `NaN` will be returned if the number is `NaN`.\n\n For signed integers, `::MIN` will be returned if the number is `::MIN`.\n"},{"kind":"Method","id":{"krate":0,"index":33},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/sign.rs","byte_start":12770,"byte_end":12777,"line_start":19,"line_end":19,"column_start":8,"column_end":15},"name":"abs_sub","qualname":"::sign::Signed::abs_sub","value":"fn (&self, other: &Self) -> Self","parent":{"krate":0,"index":30},"children":[],"decl_id":null,"docs":" The positive difference of two numbers.\n\n Returns `zero` if the number is less than or equal to `other`, otherwise the difference\n between `self` and `other` is returned.\n"},{"kind":"Method","id":{"krate":0,"index":36},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/sign.rs","byte_start":13235,"byte_end":13241,"line_start":34,"line_end":34,"column_start":8,"column_end":14},"name":"signum","qualname":"::sign::Signed::signum","value":"fn (&self) -> Self","parent":{"krate":0,"index":30},"children":[],"decl_id":null,"docs":" Returns the sign of the number.\n\n For `f32` and `f64`:\n\n * `1.0` if the number is positive, `+0.0` or `INFINITY`\n * `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`\n * `NaN` if the number is `NaN`\n\n For signed integers:\n\n * `0` if the number is zero\n * `1` if the number is positive\n * `-1` if the number is negative\n"},{"kind":"Method","id":{"krate":0,"index":38},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/sign.rs","byte_start":13358,"byte_end":13369,"line_start":37,"line_end":37,"column_start":8,"column_end":19},"name":"is_positive","qualname":"::sign::Signed::is_positive","value":"fn (&self) -> bool","parent":{"krate":0,"index":30},"children":[],"decl_id":null,"docs":" Returns true if the number is positive and false if the number is zero or negative.\n"},{"kind":"Method","id":{"krate":0,"index":40},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/sign.rs","byte_start":13486,"byte_end":13497,"line_start":40,"line_end":40,"column_start":8,"column_end":19},"name":"is_negative","qualname":"::sign::Signed::is_negative","value":"fn (&self) -> bool","parent":{"krate":0,"index":30},"children":[],"decl_id":null,"docs":" Returns true if the number is negative and false if the number is zero or positive.\n"},{"kind":"Macro","id":{"krate":4294967295,"index":4294967295},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/sign.rs","byte_start":13530,"byte_end":13541,"line_start":43,"line_end":43,"column_start":14,"column_end":25},"name":"signed_impl","qualname":"signed_impl::15438664221806507264","value":"","parent":null,"children":[],"decl_id":null,"docs":""},{"kind":"Macro","id":{"krate":4294967295,"index":4294967295},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/sign.rs","byte_start":14327,"byte_end":14344,"line_start":76,"line_end":76,"column_start":14,"column_end":31},"name":"signed_float_impl","qualname":"signed_float_impl::9393548027590410253","value":"","parent":null,"children":[],"decl_id":null,"docs":""},{"kind":"Function","id":{"krate":0,"index":42},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/sign.rs","byte_start":16112,"byte_end":16115,"line_start":124,"line_end":124,"column_start":8,"column_end":11},"name":"abs","qualname":"::sign::abs","value":"fn <T> (value: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Computes the absolute value.\n\n For `f32` and `f64`, `NaN` will be returned if the number is `NaN`\n\n For signed integers, `::MIN` will be returned if the number is `::MIN`.\n"},{"kind":"Function","id":{"krate":0,"index":45},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/sign.rs","byte_start":16352,"byte_end":16359,"line_start":133,"line_end":133,"column_start":8,"column_end":15},"name":"abs_sub","qualname":"::sign::abs_sub","value":"fn <T> (x: T, y: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" The positive difference of two numbers.\n\n Returns zero if `x` is less than or equal to `y`, otherwise the difference\n between `x` and `y` is returned.\n"},{"kind":"Function","id":{"krate":0,"index":49},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/sign.rs","byte_start":16803,"byte_end":16809,"line_start":150,"line_end":150,"column_start":26,"column_end":32},"name":"signum","qualname":"::sign::signum","value":"fn <T> (value: T) -> T","parent":null,"children":[],"decl_id":null,"docs":" Returns the sign of the number.\n\n For `f32` and `f64`:\n\n * `1.0` if the number is positive, `+0.0` or `INFINITY`\n * `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`\n * `NaN` if the number is `NaN`\n\n For signed integers:\n\n * `0` if the number is zero\n * `1` if the number is positive\n * `-1` if the number is negative\n"},{"kind":"Trait","id":{"krate":0,"index":52},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/sign.rs","byte_start":16914,"byte_end":16922,"line_start":153,"line_end":153,"column_start":11,"column_end":19},"name":"Unsigned","qualname":"::sign::Unsigned","value":"Unsigned:  Num","parent":null,"children":[],"decl_id":null,"docs":" A trait for values which cannot be negative\n"},{"kind":"Macro","id":{"krate":4294967295,"index":4294967295},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/sign.rs","byte_start":16945,"byte_end":16961,"line_start":155,"line_end":155,"column_start":14,"column_end":30},"name":"empty_trait_impl","qualname":"empty_trait_impl::16871725879093848085","value":"","parent":null,"children":[],"decl_id":null,"docs":""},{"kind":"Mod","id":{"krate":0,"index":53},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/lib.rs","byte_start":896,"byte_end":899,"line_start":27,"line_end":27,"column_start":9,"column_end":12},"name":"ops","qualname":"::ops","value":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/ops/mod.rs","parent":null,"children":[{"krate":0,"index":54},{"krate":0,"index":62}],"decl_id":null,"docs":""},{"kind":"Mod","id":{"krate":0,"index":54},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/ops/mod.rs","byte_start":17106,"byte_end":17116,"line_start":1,"line_end":1,"column_start":9,"column_end":19},"name":"saturating","qualname":"::ops::saturating","value":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/ops/saturating.rs","parent":null,"children":[{"krate":0,"index":55},{"krate":0,"index":538},{"krate":0,"index":545},{"krate":0,"index":552},{"krate":0,"index":559},{"krate":0,"index":566},{"krate":0,"index":573},{"krate":0,"index":580},{"krate":0,"index":587},{"krate":0,"index":594},{"krate":0,"index":601}],"decl_id":null,"docs":""},{"kind":"Trait","id":{"krate":0,"index":55},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/ops/saturating.rs","byte_start":17177,"byte_end":17187,"line_start":2,"line_end":2,"column_start":11,"column_end":21},"name":"Saturating","qualname":"::ops::saturating::Saturating","value":"Saturating","parent":null,"children":[{"krate":0,"index":56},{"krate":0,"index":59}],"decl_id":null,"docs":" Saturating math operations\n"},{"kind":"Method","id":{"krate":0,"index":56},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/ops/saturating.rs","byte_start":17313,"byte_end":17327,"line_start":5,"line_end":5,"column_start":8,"column_end":22},"name":"saturating_add","qualname":"::ops::saturating::Saturating::saturating_add","value":"fn (self, v: Self) -> Self","parent":{"krate":0,"index":55},"children":[],"decl_id":null,"docs":" Saturating addition operator.\n Returns a+b, saturating at the numeric bounds instead of overflowing.\n"},{"kind":"Method","id":{"krate":0,"index":59},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/ops/saturating.rs","byte_start":17479,"byte_end":17493,"line_start":9,"line_end":9,"column_start":8,"column_end":22},"name":"saturating_sub","qualname":"::ops::saturating::Saturating::saturating_sub","value":"fn (self, v: Self) -> Self","parent":{"krate":0,"index":55},"children":[],"decl_id":null,"docs":" Saturating subtraction operator.\n Returns a-b, saturating at the numeric bounds instead of overflowing.\n"},{"kind":"Macro","id":{"krate":4294967295,"index":4294967295},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/ops/saturating.rs","byte_start":17534,"byte_end":17549,"line_start":12,"line_end":12,"column_start":14,"column_end":29},"name":"saturating_impl","qualname":"saturating_impl::3465867693250566239","value":"","parent":null,"children":[],"decl_id":null,"docs":""},{"kind":"Mod","id":{"krate":0,"index":62},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/ops/mod.rs","byte_start":17126,"byte_end":17133,"line_start":2,"line_end":2,"column_start":9,"column_end":16},"name":"checked","qualname":"::ops::checked","value":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/ops/checked.rs","parent":null,"children":[{"krate":0,"index":63},{"krate":0,"index":64},{"krate":0,"index":608},{"krate":0,"index":612},{"krate":0,"index":616},{"krate":0,"index":620},{"krate":0,"index":624},{"krate":0,"index":628},{"krate":0,"index":632},{"krate":0,"index":636},{"krate":0,"index":640},{"krate":0,"index":644},{"krate":0,"index":68},{"krate":0,"index":648},{"krate":0,"index":652},{"krate":0,"index":656},{"krate":0,"index":660},{"krate":0,"index":664},{"krate":0,"index":668},{"krate":0,"index":672},{"krate":0,"index":676},{"krate":0,"index":680},{"krate":0,"index":684},{"krate":0,"index":72},{"krate":0,"index":688},{"krate":0,"index":692},{"krate":0,"index":696},{"krate":0,"index":700},{"krate":0,"index":704},{"krate":0,"index":708},{"krate":0,"index":712},{"krate":0,"index":716},{"krate":0,"index":720},{"krate":0,"index":724},{"krate":0,"index":76},{"krate":0,"index":728},{"krate":0,"index":732},{"krate":0,"index":736},{"krate":0,"index":740},{"krate":0,"index":744},{"krate":0,"index":748},{"krate":0,"index":752},{"krate":0,"index":756},{"krate":0,"index":760},{"krate":0,"index":764}],"decl_id":null,"docs":""},{"kind":"Trait","id":{"krate":0,"index":64},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/ops/checked.rs","byte_start":18137,"byte_end":18147,"line_start":5,"line_end":5,"column_start":11,"column_end":21},"name":"CheckedAdd","qualname":"::ops::checked::CheckedAdd","value":"CheckedAdd:  Sized + Add<Self, Output = Self>","parent":null,"children":[{"krate":0,"index":65}],"decl_id":null,"docs":" Performs addition that returns `None` instead of wrapping around on\n overflow.\n"},{"kind":"Method","id":{"krate":0,"index":65},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/ops/checked.rs","byte_start":18287,"byte_end":18298,"line_start":8,"line_end":8,"column_start":8,"column_end":19},"name":"checked_add","qualname":"::ops::checked::CheckedAdd::checked_add","value":"fn (&self, v: &Self) -> Option<Self>","parent":{"krate":0,"index":64},"children":[],"decl_id":null,"docs":" Adds two numbers, checking for overflow. If overflow happens, `None` is\n returned.\n"},{"kind":"Macro","id":{"krate":4294967295,"index":4294967295},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/ops/checked.rs","byte_start":18349,"byte_end":18361,"line_start":11,"line_end":11,"column_start":14,"column_end":26},"name":"checked_impl","qualname":"checked_impl::14978622730324619020","value":"","parent":null,"children":[],"decl_id":null,"docs":""},{"kind":"Trait","id":{"krate":0,"index":68},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/ops/checked.rs","byte_start":19149,"byte_end":19159,"line_start":35,"line_end":35,"column_start":11,"column_end":21},"name":"CheckedSub","qualname":"::ops::checked::CheckedSub","value":"CheckedSub:  Sized + Sub<Self, Output = Self>","parent":null,"children":[{"krate":0,"index":69}],"decl_id":null,"docs":" Performs subtraction that returns `None` instead of wrapping around on underflow.\n"},{"kind":"Method","id":{"krate":0,"index":69},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/ops/checked.rs","byte_start":19306,"byte_end":19317,"line_start":38,"line_end":38,"column_start":8,"column_end":19},"name":"checked_sub","qualname":"::ops::checked::CheckedSub::checked_sub","value":"fn (&self, v: &Self) -> Option<Self>","parent":{"krate":0,"index":68},"children":[],"decl_id":null,"docs":" Subtracts two numbers, checking for underflow. If underflow happens,\n `None` is returned.\n"},{"kind":"Trait","id":{"krate":0,"index":72},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/ops/checked.rs","byte_start":19924,"byte_end":19934,"line_start":55,"line_end":55,"column_start":11,"column_end":21},"name":"CheckedMul","qualname":"::ops::checked::CheckedMul","value":"CheckedMul:  Sized + Mul<Self, Output = Self>","parent":null,"children":[{"krate":0,"index":73}],"decl_id":null,"docs":" Performs multiplication that returns `None` instead of wrapping around on underflow or\n overflow.\n"},{"kind":"Method","id":{"krate":0,"index":73},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/ops/checked.rs","byte_start":20106,"byte_end":20117,"line_start":58,"line_end":58,"column_start":8,"column_end":19},"name":"checked_mul","qualname":"::ops::checked::CheckedMul::checked_mul","value":"fn (&self, v: &Self) -> Option<Self>","parent":{"krate":0,"index":72},"children":[],"decl_id":null,"docs":" Multiplies two numbers, checking for underflow or overflow. If underflow\n or overflow happens, `None` is returned.\n"},{"kind":"Trait","id":{"krate":0,"index":76},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/ops/checked.rs","byte_start":20764,"byte_end":20774,"line_start":75,"line_end":75,"column_start":11,"column_end":21},"name":"CheckedDiv","qualname":"::ops::checked::CheckedDiv","value":"CheckedDiv:  Sized + Div<Self, Output = Self>","parent":null,"children":[{"krate":0,"index":77}],"decl_id":null,"docs":" Performs division that returns `None` instead of panicking on division by zero and instead of\n wrapping around on underflow and overflow.\n"},{"kind":"Method","id":{"krate":0,"index":77},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/ops/checked.rs","byte_start":20952,"byte_end":20963,"line_start":78,"line_end":78,"column_start":8,"column_end":19},"name":"checked_div","qualname":"::ops::checked::CheckedDiv::checked_div","value":"fn (&self, v: &Self) -> Option<Self>","parent":{"krate":0,"index":76},"children":[],"decl_id":null,"docs":" Divides two numbers, checking for underflow, overflow and division by\n zero. If any of that happens, `None` is returned.\n"},{"kind":"Mod","id":{"krate":0,"index":80},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/lib.rs","byte_start":909,"byte_end":915,"line_start":28,"line_end":28,"column_start":9,"column_end":15},"name":"bounds","qualname":"::bounds","value":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/bounds.rs","parent":null,"children":[{"krate":0,"index":81},{"krate":0,"index":82},{"krate":0,"index":83},{"krate":0,"index":84},{"krate":0,"index":768},{"krate":0,"index":771},{"krate":0,"index":774},{"krate":0,"index":777},{"krate":0,"index":780},{"krate":0,"index":783},{"krate":0,"index":786},{"krate":0,"index":789},{"krate":0,"index":792},{"krate":0,"index":795},{"krate":0,"index":798},{"krate":0,"index":801},{"krate":0,"index":824},{"krate":0,"index":846},{"krate":0,"index":867},{"krate":0,"index":887},{"krate":0,"index":906},{"krate":0,"index":924},{"krate":0,"index":941},{"krate":0,"index":957},{"krate":0,"index":972},{"krate":0,"index":986},{"krate":0,"index":999},{"krate":0,"index":1011},{"krate":0,"index":1022},{"krate":0,"index":1032},{"krate":0,"index":1041},{"krate":0,"index":1049},{"krate":0,"index":1056},{"krate":0,"index":1062},{"krate":0,"index":1067},{"krate":0,"index":1071},{"krate":0,"index":1074}],"decl_id":null,"docs":""},{"kind":"Trait","id":{"krate":0,"index":84},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/bounds.rs","byte_start":21607,"byte_end":21614,"line_start":6,"line_end":6,"column_start":11,"column_end":18},"name":"Bounded","qualname":"::bounds::Bounded","value":"Bounded","parent":null,"children":[{"krate":0,"index":85},{"krate":0,"index":86}],"decl_id":null,"docs":" Numbers which have upper and lower bounds\n"},{"kind":"Method","id":{"krate":0,"index":85},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/bounds.rs","byte_start":21750,"byte_end":21759,"line_start":9,"line_end":9,"column_start":8,"column_end":17},"name":"min_value","qualname":"::bounds::Bounded::min_value","value":"fn () -> Self","parent":{"krate":0,"index":84},"children":[],"decl_id":null,"docs":" returns the smallest finite number this type can represent\n"},{"kind":"Method","id":{"krate":0,"index":86},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/bounds.rs","byte_start":21844,"byte_end":21853,"line_start":11,"line_end":11,"column_start":8,"column_end":17},"name":"max_value","qualname":"::bounds::Bounded::max_value","value":"fn () -> Self","parent":{"krate":0,"index":84},"children":[],"decl_id":null,"docs":" returns the largest finite number this type can represent\n"},{"kind":"Macro","id":{"krate":4294967295,"index":4294967295},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/bounds.rs","byte_start":21881,"byte_end":21893,"line_start":14,"line_end":14,"column_start":14,"column_end":26},"name":"bounded_impl","qualname":"bounded_impl::13948946203301374156","value":"","parent":null,"children":[],"decl_id":null,"docs":""},{"kind":"Macro","id":{"krate":4294967295,"index":4294967295},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/bounds.rs","byte_start":22817,"byte_end":22831,"line_start":49,"line_end":49,"column_start":14,"column_end":28},"name":"for_each_tuple","qualname":"for_each_tuple::7366704169855883644","value":"","parent":null,"children":[],"decl_id":null,"docs":""},{"kind":"Mod","id":{"krate":0,"index":87},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/lib.rs","byte_start":925,"byte_end":930,"line_start":29,"line_end":29,"column_start":9,"column_end":14},"name":"float","qualname":"::float","value":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/float.rs","parent":null,"children":[{"krate":0,"index":88},{"krate":0,"index":89},{"krate":0,"index":90},{"krate":0,"index":91},{"krate":0,"index":92},{"krate":0,"index":93},{"krate":0,"index":214},{"krate":0,"index":220},{"krate":0,"index":1077},{"krate":0,"index":1194},{"krate":0,"index":1311},{"krate":0,"index":1328},{"krate":0,"index":1345}],"decl_id":null,"docs":""},{"kind":"Trait","id":{"krate":0,"index":93},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/float.rs","byte_start":23703,"byte_end":23708,"line_start":13,"line_end":13,"column_start":11,"column_end":16},"name":"Float","qualname":"::float::Float","value":"Float:  Num + Copy + NumCast + PartialOrd + Neg<Output = Self>","parent":null,"children":[{"krate":0,"index":94},{"krate":0,"index":95},{"krate":0,"index":96},{"krate":0,"index":97},{"krate":0,"index":98},{"krate":0,"index":99},{"krate":0,"index":100},{"krate":0,"index":101},{"krate":0,"index":102},{"krate":0,"index":104},{"krate":0,"index":106},{"krate":0,"index":108},{"krate":0,"index":110},{"krate":0,"index":112},{"krate":0,"index":114},{"krate":0,"index":116},{"krate":0,"index":118},{"krate":0,"index":120},{"krate":0,"index":122},{"krate":0,"index":124},{"krate":0,"index":126},{"krate":0,"index":128},{"krate":0,"index":130},{"krate":0,"index":134},{"krate":0,"index":136},{"krate":0,"index":139},{"krate":0,"index":142},{"krate":0,"index":144},{"krate":0,"index":146},{"krate":0,"index":148},{"krate":0,"index":150},{"krate":0,"index":153},{"krate":0,"index":155},{"krate":0,"index":157},{"krate":0,"index":161},{"krate":0,"index":165},{"krate":0,"index":168},{"krate":0,"index":171},{"krate":0,"index":174},{"krate":0,"index":176},{"krate":0,"index":179},{"krate":0,"index":181},{"krate":0,"index":183},{"krate":0,"index":185},{"krate":0,"index":187},{"krate":0,"index":189},{"krate":0,"index":191},{"krate":0,"index":194},{"krate":0,"index":196},{"krate":0,"index":198},{"krate":0,"index":200},{"krate":0,"index":202},{"krate":0,"index":204},{"krate":0,"index":206},{"krate":0,"index":208},{"krate":0,"index":210},{"krate":0,"index":212}],"decl_id":null,"docs":""},{"kind":"Method","id":{"krate":0,"index":94},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/float.rs","byte_start":23975,"byte_end":23978,"line_start":29,"line_end":29,"column_start":8,"column_end":11},"name":"nan","qualname":"::float::Float::nan","value":"fn () -> Self","parent":{"krate":0,"index":93},"children":[],"decl_id":null,"docs":" Returns the `NaN` value.\n\n ```\n use num_traits::Float;\n\n let nan: f32 = Float::nan();\n\n assert!(nan.is_nan());\n ```\n"},{"kind":"Method","id":{"krate":0,"index":95},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/float.rs","byte_start":24300,"byte_end":24308,"line_start":42,"line_end":42,"column_start":8,"column_end":16},"name":"infinity","qualname":"::float::Float::infinity","value":"fn () -> Self","parent":{"krate":0,"index":93},"children":[],"decl_id":null,"docs":" Returns the infinite value.\n\n ```\n use num_traits::Float;\n use std::f32;\n\n let infinity: f32 = Float::infinity();\n\n assert!(infinity.is_infinite());\n assert!(!infinity.is_finite());\n assert!(infinity > f32::MAX);\n ```\n"},{"kind":"Method","id":{"krate":0,"index":96},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/float.rs","byte_start":24659,"byte_end":24671,"line_start":55,"line_end":55,"column_start":8,"column_end":20},"name":"neg_infinity","qualname":"::float::Float::neg_infinity","value":"fn () -> Self","parent":{"krate":0,"index":93},"children":[],"decl_id":null,"docs":" Returns the negative infinite value.\n\n ```\n use num_traits::Float;\n use std::f32;\n\n let neg_infinity: f32 = Float::neg_infinity();\n\n assert!(neg_infinity.is_infinite());\n assert!(!neg_infinity.is_finite());\n assert!(neg_infinity < f32::MIN);\n ```\n"},{"kind":"Method","id":{"krate":0,"index":97},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/float.rs","byte_start":25041,"byte_end":25049,"line_start":69,"line_end":69,"column_start":8,"column_end":16},"name":"neg_zero","qualname":"::float::Float::neg_zero","value":"fn () -> Self","parent":{"krate":0,"index":93},"children":[],"decl_id":null,"docs":" Returns `-0.0`.\n\n ```\n use num_traits::{Zero, Float};\n\n let inf: f32 = Float::infinity();\n let zero: f32 = Zero::zero();\n let neg_zero: f32 = Float::neg_zero();\n\n assert_eq!(zero, neg_zero);\n assert_eq!(7.0f32/inf, zero);\n assert_eq!(zero * 10.0, zero);\n ```\n"},{"kind":"Method","id":{"krate":0,"index":98},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/float.rs","byte_start":25316,"byte_end":25325,"line_start":81,"line_end":81,"column_start":8,"column_end":17},"name":"min_value","qualname":"::float::Float::min_value","value":"fn () -> Self","parent":{"krate":0,"index":93},"children":[],"decl_id":null,"docs":" Returns the smallest finite value that this type can represent.\n\n ```\n use num_traits::Float;\n use std::f64;\n\n let x: f64 = Float::min_value();\n\n assert_eq!(x, f64::MIN);\n ```\n"},{"kind":"Method","id":{"krate":0,"index":99},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/float.rs","byte_start":25624,"byte_end":25642,"line_start":93,"line_end":93,"column_start":8,"column_end":26},"name":"min_positive_value","qualname":"::float::Float::min_positive_value","value":"fn () -> Self","parent":{"krate":0,"index":93},"children":[],"decl_id":null,"docs":" Returns the smallest positive, normalized value that this type can represent.\n\n ```\n use num_traits::Float;\n use std::f64;\n\n let x: f64 = Float::min_positive_value();\n\n assert_eq!(x, f64::MIN_POSITIVE);\n ```\n"},{"kind":"Method","id":{"krate":0,"index":100},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/float.rs","byte_start":26019,"byte_end":26026,"line_start":110,"line_end":110,"column_start":8,"column_end":15},"name":"epsilon","qualname":"::float::Float::epsilon","value":"fn () -> Self","parent":{"krate":0,"index":93},"children":[],"decl_id":null,"docs":" Returns epsilon, a small positive value.\n\n ```\n use num_traits::Float;\n use std::f64;\n\n let x: f64 = Float::epsilon();\n\n assert_eq!(x, f64::EPSILON);\n ```\n\n # Panics\n\n The default implementation will panic if `f32::EPSILON` cannot\n be cast to `Self`.\n"},{"kind":"Method","id":{"krate":0,"index":101},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/float.rs","byte_start":26367,"byte_end":26376,"line_start":123,"line_end":123,"column_start":8,"column_end":17},"name":"max_value","qualname":"::float::Float::max_value","value":"fn () -> Self","parent":{"krate":0,"index":93},"children":[],"decl_id":null,"docs":" Returns the largest finite value that this type can represent.\n\n ```\n use num_traits::Float;\n use std::f64;\n\n let x: f64 = Float::max_value();\n assert_eq!(x, f64::MAX);\n ```\n"},{"kind":"Method","id":{"krate":0,"index":102},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/float.rs","byte_start":26674,"byte_end":26680,"line_start":137,"line_end":137,"column_start":8,"column_end":14},"name":"is_nan","qualname":"::float::Float::is_nan","value":"fn (self) -> bool","parent":{"krate":0,"index":93},"children":[],"decl_id":null,"docs":" Returns `true` if this value is `NaN` and false otherwise.\n\n ```\n use num_traits::Float;\n use std::f64;\n\n let nan = f64::NAN;\n let f = 7.0;\n\n assert!(nan.is_nan());\n assert!(!f.is_nan());\n ```\n"},{"kind":"Method","id":{"krate":0,"index":104},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/float.rs","byte_start":27218,"byte_end":27229,"line_start":157,"line_end":157,"column_start":8,"column_end":19},"name":"is_infinite","qualname":"::float::Float::is_infinite","value":"fn (self) -> bool","parent":{"krate":0,"index":93},"children":[],"decl_id":null,"docs":" Returns `true` if this value is positive infinity or negative infinity and\n false otherwise.\n\n ```\n use num_traits::Float;\n use std::f32;\n\n let f = 7.0f32;\n let inf: f32 = Float::infinity();\n let neg_inf: f32 = Float::neg_infinity();\n let nan: f32 = f32::NAN;\n\n assert!(!f.is_infinite());\n assert!(!nan.is_infinite());\n\n assert!(inf.is_infinite());\n assert!(neg_inf.is_infinite());\n ```\n"},{"kind":"Method","id":{"krate":0,"index":106},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/float.rs","byte_start":27721,"byte_end":27730,"line_start":176,"line_end":176,"column_start":8,"column_end":17},"name":"is_finite","qualname":"::float::Float::is_finite","value":"fn (self) -> bool","parent":{"krate":0,"index":93},"children":[],"decl_id":null,"docs":" Returns `true` if this number is neither infinite nor `NaN`.\n\n ```\n use num_traits::Float;\n use std::f32;\n\n let f = 7.0f32;\n let inf: f32 = Float::infinity();\n let neg_inf: f32 = Float::neg_infinity();\n let nan: f32 = f32::NAN;\n\n assert!(f.is_finite());\n\n assert!(!nan.is_finite());\n assert!(!inf.is_finite());\n assert!(!neg_inf.is_finite());\n ```\n"},{"kind":"Method","id":{"krate":0,"index":108},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/float.rs","byte_start":28480,"byte_end":28489,"line_start":200,"line_end":200,"column_start":8,"column_end":17},"name":"is_normal","qualname":"::float::Float::is_normal","value":"fn (self) -> bool","parent":{"krate":0,"index":93},"children":[],"decl_id":null,"docs":" Returns `true` if the number is neither zero, infinite,\n [subnormal][subnormal], or `NaN`.\n\n ```\n use num_traits::Float;\n use std::f32;\n\n let min = f32::MIN_POSITIVE; // 1.17549435e-38f32\n let max = f32::MAX;\n let lower_than_min = 1.0e-40_f32;\n let zero = 0.0f32;\n\n assert!(min.is_normal());\n assert!(max.is_normal());\n\n assert!(!zero.is_normal());\n assert!(!f32::NAN.is_normal());\n assert!(!f32::INFINITY.is_normal());\n // Values between `0` and `min` are Subnormal.\n assert!(!lower_than_min.is_normal());\n ```\n [subnormal]: http://en.wikipedia.org/wiki/Denormal_number\n"},{"kind":"Method","id":{"krate":0,"index":110},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/float.rs","byte_start":29003,"byte_end":29011,"line_start":217,"line_end":217,"column_start":8,"column_end":16},"name":"classify","qualname":"::float::Float::classify","value":"fn (self) -> FpCategory","parent":{"krate":0,"index":93},"children":[],"decl_id":null,"docs":" Returns the floating point category of the number. If only one property\n is going to be tested, it is generally faster to use the specific\n predicate instead.\n\n ```\n use num_traits::Float;\n use std::num::FpCategory;\n use std::f32;\n\n let num = 12.4f32;\n let inf = f32::INFINITY;\n\n assert_eq!(num.classify(), FpCategory::Normal);\n assert_eq!(inf.classify(), FpCategory::Infinite);\n ```\n"},{"kind":"Method","id":{"krate":0,"index":112},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/float.rs","byte_start":29303,"byte_end":29308,"line_start":230,"line_end":230,"column_start":8,"column_end":13},"name":"floor","qualname":"::float::Float::floor","value":"fn (self) -> Self","parent":{"krate":0,"index":93},"children":[],"decl_id":null,"docs":" Returns the largest integer less than or equal to a number.\n\n ```\n use num_traits::Float;\n\n let f = 3.99;\n let g = 3.0;\n\n assert_eq!(f.floor(), 3.0);\n assert_eq!(g.floor(), 3.0);\n ```\n"},{"kind":"Method","id":{"krate":0,"index":114},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/float.rs","byte_start":29596,"byte_end":29600,"line_start":243,"line_end":243,"column_start":8,"column_end":12},"name":"ceil","qualname":"::float::Float::ceil","value":"fn (self) -> Self","parent":{"krate":0,"index":93},"children":[],"decl_id":null,"docs":" Returns the smallest integer greater than or equal to a number.\n\n ```\n use num_traits::Float;\n\n let f = 3.01;\n let g = 4.0;\n\n assert_eq!(f.ceil(), 4.0);\n assert_eq!(g.ceil(), 4.0);\n ```\n"},{"kind":"Method","id":{"krate":0,"index":116},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/float.rs","byte_start":29914,"byte_end":29919,"line_start":257,"line_end":257,"column_start":8,"column_end":13},"name":"round","qualname":"::float::Float::round","value":"fn (self) -> Self","parent":{"krate":0,"index":93},"children":[],"decl_id":null,"docs":" Returns the nearest integer to a number. Round half-way cases away from\n `0.0`.\n\n ```\n use num_traits::Float;\n\n let f = 3.3;\n let g = -3.3;\n\n assert_eq!(f.round(), 3.0);\n assert_eq!(g.round(), -3.0);\n ```\n"},{"kind":"Method","id":{"krate":0,"index":118},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/float.rs","byte_start":30183,"byte_end":30188,"line_start":270,"line_end":270,"column_start":8,"column_end":13},"name":"trunc","qualname":"::float::Float::trunc","value":"fn (self) -> Self","parent":{"krate":0,"index":93},"children":[],"decl_id":null,"docs":" Return the integer part of a number.\n\n ```\n use num_traits::Float;\n\n let f = 3.3;\n let g = -3.7;\n\n assert_eq!(f.trunc(), 3.0);\n assert_eq!(g.trunc(), -3.0);\n ```\n"},{"kind":"Method","id":{"krate":0,"index":120},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/float.rs","byte_start":30584,"byte_end":30589,"line_start":285,"line_end":285,"column_start":8,"column_end":13},"name":"fract","qualname":"::float::Float::fract","value":"fn (self) -> Self","parent":{"krate":0,"index":93},"children":[],"decl_id":null,"docs":" Returns the fractional part of a number.\n\n ```\n use num_traits::Float;\n\n let x = 3.5;\n let y = -3.5;\n let abs_difference_x = (x.fract() - 0.5).abs();\n let abs_difference_y = (y.fract() - (-0.5)).abs();\n\n assert!(abs_difference_x < 1e-10);\n assert!(abs_difference_y < 1e-10);\n ```\n"},{"kind":"Method","id":{"krate":0,"index":122},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/float.rs","byte_start":31119,"byte_end":31122,"line_start":305,"line_end":305,"column_start":8,"column_end":11},"name":"abs","qualname":"::float::Float::abs","value":"fn (self) -> Self","parent":{"krate":0,"index":93},"children":[],"decl_id":null,"docs":" Computes the absolute value of `self`. Returns `Float::nan()` if the\n number is `Float::nan()`.\n\n ```\n use num_traits::Float;\n use std::f64;\n\n let x = 3.5;\n let y = -3.5;\n\n let abs_difference_x = (x.abs() - x).abs();\n let abs_difference_y = (y.abs() - (-y)).abs();\n\n assert!(abs_difference_x < 1e-10);\n assert!(abs_difference_y < 1e-10);\n\n assert!(f64::NAN.abs().is_nan());\n ```\n"},{"kind":"Method","id":{"krate":0,"index":124},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/float.rs","byte_start":31689,"byte_end":31695,"line_start":324,"line_end":324,"column_start":8,"column_end":14},"name":"signum","qualname":"::float::Float::signum","value":"fn (self) -> Self","parent":{"krate":0,"index":93},"children":[],"decl_id":null,"docs":" Returns a number that represents the sign of `self`.\n\n - `1.0` if the number is positive, `+0.0` or `Float::infinity()`\n - `-1.0` if the number is negative, `-0.0` or `Float::neg_infinity()`\n - `Float::nan()` if the number is `Float::nan()`\n\n ```\n use num_traits::Float;\n use std::f64;\n\n let f = 3.5;\n\n assert_eq!(f.signum(), 1.0);\n assert_eq!(f64::NEG_INFINITY.signum(), -1.0);\n\n assert!(f64::NAN.signum().is_nan());\n ```\n"},{"kind":"Method","id":{"krate":0,"index":126},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/float.rs","byte_start":32204,"byte_end":32220,"line_start":343,"line_end":343,"column_start":8,"column_end":24},"name":"is_sign_positive","qualname":"::float::Float::is_sign_positive","value":"fn (self) -> bool","parent":{"krate":0,"index":93},"children":[],"decl_id":null,"docs":" Returns `true` if `self` is positive, including `+0.0` and\n `Float::infinity()`.\n\n ```\n use num_traits::Float;\n use std::f64;\n\n let nan: f64 = f64::NAN;\n\n let f = 7.0;\n let g = -7.0;\n\n assert!(f.is_sign_positive());\n assert!(!g.is_sign_positive());\n // Requires both tests to determine if is `NaN`\n assert!(!nan.is_sign_positive() && !nan.is_sign_negative());\n ```\n"},{"kind":"Method","id":{"krate":0,"index":128},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/float.rs","byte_start":32729,"byte_end":32745,"line_start":362,"line_end":362,"column_start":8,"column_end":24},"name":"is_sign_negative","qualname":"::float::Float::is_sign_negative","value":"fn (self) -> bool","parent":{"krate":0,"index":93},"children":[],"decl_id":null,"docs":" Returns `true` if `self` is negative, including `-0.0` and\n `Float::neg_infinity()`.\n\n ```\n use num_traits::Float;\n use std::f64;\n\n let nan = f64::NAN;\n\n let f = 7.0;\n let g = -7.0;\n\n assert!(!f.is_sign_negative());\n assert!(g.is_sign_negative());\n // Requires both tests to determine if is `NaN`.\n assert!(!nan.is_sign_positive() && !nan.is_sign_negative());\n ```\n"},{"kind":"Method","id":{"krate":0,"index":130},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/float.rs","byte_start":33267,"byte_end":33274,"line_start":380,"line_end":380,"column_start":8,"column_end":15},"name":"mul_add","qualname":"::float::Float::mul_add","value":"fn (self, a: Self, b: Self) -> Self","parent":{"krate":0,"index":93},"children":[],"decl_id":null,"docs":" Fused multiply-add. Computes `(self * a) + b` with only one rounding\n error. This produces a more accurate result with better performance than\n a separate multiplication operation followed by an add.\n\n ```\n use num_traits::Float;\n\n let m = 10.0;\n let x = 4.0;\n let b = 60.0;\n\n // 100.0\n let abs_difference = (m.mul_add(x, b) - (m*x + b)).abs();\n\n assert!(abs_difference < 1e-10);\n ```\n"},{"kind":"Method","id":{"krate":0,"index":134},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/float.rs","byte_start":33572,"byte_end":33577,"line_start":391,"line_end":391,"column_start":8,"column_end":13},"name":"recip","qualname":"::float::Float::recip","value":"fn (self) -> Self","parent":{"krate":0,"index":93},"children":[],"decl_id":null,"docs":" Take the reciprocal (inverse) of a number, `1/x`.\n\n ```\n use num_traits::Float;\n\n let x = 2.0;\n let abs_difference = (x.recip() - (1.0/x)).abs();\n\n assert!(abs_difference < 1e-10);\n ```\n"},{"kind":"Method","id":{"krate":0,"index":136},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/float.rs","byte_start":33914,"byte_end":33918,"line_start":405,"line_end":405,"column_start":8,"column_end":12},"name":"powi","qualname":"::float::Float::powi","value":"fn (self, n: i32) -> Self","parent":{"krate":0,"index":93},"children":[],"decl_id":null,"docs":" Raise a number to an integer power.\n\n Using this function is generally faster than using `powf`\n\n ```\n use num_traits::Float;\n\n let x = 2.0;\n let abs_difference = (x.powi(2) - x*x).abs();\n\n assert!(abs_difference < 1e-10);\n ```\n"},{"kind":"Method","id":{"krate":0,"index":139},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/float.rs","byte_start":34197,"byte_end":34201,"line_start":417,"line_end":417,"column_start":8,"column_end":12},"name":"powf","qualname":"::float::Float::powf","value":"fn (self, n: Self) -> Self","parent":{"krate":0,"index":93},"children":[],"decl_id":null,"docs":" Raise a number to a floating point power.\n\n ```\n use num_traits::Float;\n\n let x = 2.0;\n let abs_difference = (x.powf(2.0) - x*x).abs();\n\n assert!(abs_difference < 1e-10);\n ```\n"},{"kind":"Method","id":{"krate":0,"index":142},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/float.rs","byte_start":34624,"byte_end":34628,"line_start":434,"line_end":434,"column_start":8,"column_end":12},"name":"sqrt","qualname":"::float::Float::sqrt","value":"fn (self) -> Self","parent":{"krate":0,"index":93},"children":[],"decl_id":null,"docs":" Take the square root of a number.\n\n Returns NaN if `self` is a negative number.\n\n ```\n use num_traits::Float;\n\n let positive = 4.0;\n let negative = -4.0;\n\n let abs_difference = (positive.sqrt() - 2.0).abs();\n\n assert!(abs_difference < 1e-10);\n assert!(negative.sqrt().is_nan());\n ```\n"},{"kind":"Method","id":{"krate":0,"index":144},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/float.rs","byte_start":34978,"byte_end":34981,"line_start":450,"line_end":450,"column_start":8,"column_end":11},"name":"exp","qualname":"::float::Float::exp","value":"fn (self) -> Self","parent":{"krate":0,"index":93},"children":[],"decl_id":null,"docs":" Returns `e^(self)`, (the exponential function).\n\n ```\n use num_traits::Float;\n\n let one = 1.0;\n // e^1\n let e = one.exp();\n\n // ln(e) - 1 == 0\n let abs_difference = (e.ln() - 1.0).abs();\n\n assert!(abs_difference < 1e-10);\n ```\n"},{"kind":"Method","id":{"krate":0,"index":146},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/float.rs","byte_start":35259,"byte_end":35263,"line_start":464,"line_end":464,"column_start":8,"column_end":12},"name":"exp2","qualname":"::float::Float::exp2","value":"fn (self) -> Self","parent":{"krate":0,"index":93},"children":[],"decl_id":null,"docs":" Returns `2^(self)`.\n\n ```\n use num_traits::Float;\n\n let f = 2.0;\n\n // 2^2 - 4 == 0\n let abs_difference = (f.exp2() - 4.0).abs();\n\n assert!(abs_difference < 1e-10);\n ```\n"},{"kind":"Method","id":{"krate":0,"index":148},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/float.rs","byte_start":35610,"byte_end":35612,"line_start":480,"line_end":480,"column_start":8,"column_end":10},"name":"ln","qualname":"::float::Float::ln","value":"fn (self) -> Self","parent":{"krate":0,"index":93},"children":[],"decl_id":null,"docs":" Returns the natural logarithm of the number.\n\n ```\n use num_traits::Float;\n\n let one = 1.0;\n // e^1\n let e = one.exp();\n\n // ln(e) - 1 == 0\n let abs_difference = (e.ln() - 1.0).abs();\n\n assert!(abs_difference < 1e-10);\n ```\n"},{"kind":"Method","id":{"krate":0,"index":150},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/float.rs","byte_start":36122,"byte_end":36125,"line_start":499,"line_end":499,"column_start":8,"column_end":11},"name":"log","qualname":"::float::Float::log","value":"fn (self, base: Self) -> Self","parent":{"krate":0,"index":93},"children":[],"decl_id":null,"docs":" Returns the logarithm of the number with respect to an arbitrary base.\n\n ```\n use num_traits::Float;\n\n let ten = 10.0;\n let two = 2.0;\n\n // log10(10) - 1 == 0\n let abs_difference_10 = (ten.log(10.0) - 1.0).abs();\n\n // log2(2) - 1 == 0\n let abs_difference_2 = (two.log(2.0) - 1.0).abs();\n\n assert!(abs_difference_10 < 1e-10);\n assert!(abs_difference_2 < 1e-10);\n ```\n"},{"kind":"Method","id":{"krate":0,"index":153},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/float.rs","byte_start":36447,"byte_end":36451,"line_start":513,"line_end":513,"column_start":8,"column_end":12},"name":"log2","qualname":"::float::Float::log2","value":"fn (self) -> Self","parent":{"krate":0,"index":93},"children":[],"decl_id":null,"docs":" Returns the base 2 logarithm of the number.\n\n ```\n use num_traits::Float;\n\n let two = 2.0;\n\n // log2(2) - 1 == 0\n let abs_difference = (two.log2() - 1.0).abs();\n\n assert!(abs_difference < 1e-10);\n ```\n"},{"kind":"Method","id":{"krate":0,"index":155},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/float.rs","byte_start":36766,"byte_end":36771,"line_start":527,"line_end":527,"column_start":8,"column_end":13},"name":"log10","qualname":"::float::Float::log10","value":"fn (self) -> Self","parent":{"krate":0,"index":93},"children":[],"decl_id":null,"docs":" Returns the base 10 logarithm of the number.\n\n ```\n use num_traits::Float;\n\n let ten = 10.0;\n\n // log10(10) - 1 == 0\n let abs_difference = (ten.log10() - 1.0).abs();\n\n assert!(abs_difference < 1e-10);\n ```\n"},{"kind":"Method","id":{"krate":0,"index":157},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/float.rs","byte_start":37070,"byte_end":37080,"line_start":541,"line_end":541,"column_start":8,"column_end":18},"name":"to_degrees","qualname":"::float::Float::to_degrees","value":"fn (self) -> Self","parent":{"krate":0,"index":93},"children":[],"decl_id":null,"docs":" Converts radians to degrees.\n\n ```\n use std::f64::consts;\n\n let angle = consts::PI;\n\n let abs_difference = (angle.to_degrees() - 180.0).abs();\n\n assert!(abs_difference < 1e-10);\n ```\n"},{"kind":"Method","id":{"krate":0,"index":161},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/float.rs","byte_start":37511,"byte_end":37521,"line_start":559,"line_end":559,"column_start":8,"column_end":18},"name":"to_radians","qualname":"::float::Float::to_radians","value":"fn (self) -> Self","parent":{"krate":0,"index":93},"children":[],"decl_id":null,"docs":" Converts degrees to radians.\n\n ```\n use std::f64::consts;\n\n let angle = 180.0_f64;\n\n let abs_difference = (angle.to_radians() - consts::PI).abs();\n\n assert!(abs_difference < 1e-10);\n ```\n"},{"kind":"Method","id":{"krate":0,"index":165},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/float.rs","byte_start":37875,"byte_end":37878,"line_start":575,"line_end":575,"column_start":8,"column_end":11},"name":"max","qualname":"::float::Float::max","value":"fn (self, other: Self) -> Self","parent":{"krate":0,"index":93},"children":[],"decl_id":null,"docs":" Returns the maximum of the two numbers.\n\n ```\n use num_traits::Float;\n\n let x = 1.0;\n let y = 2.0;\n\n assert_eq!(x.max(y), y);\n ```\n"},{"kind":"Method","id":{"krate":0,"index":168},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/float.rs","byte_start":38117,"byte_end":38120,"line_start":587,"line_end":587,"column_start":8,"column_end":11},"name":"min","qualname":"::float::Float::min","value":"fn (self, other: Self) -> Self","parent":{"krate":0,"index":93},"children":[],"decl_id":null,"docs":" Returns the minimum of the two numbers.\n\n ```\n use num_traits::Float;\n\n let x = 1.0;\n let y = 2.0;\n\n assert_eq!(x.min(y), x);\n ```\n"},{"kind":"Method","id":{"krate":0,"index":171},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/float.rs","byte_start":38618,"byte_end":38625,"line_start":606,"line_end":606,"column_start":8,"column_end":15},"name":"abs_sub","qualname":"::float::Float::abs_sub","value":"fn (self, other: Self) -> Self","parent":{"krate":0,"index":93},"children":[],"decl_id":null,"docs":" The positive difference of two numbers.\n\n * If `self <= other`: `0:0`\n * Else: `self - other`\n\n ```\n use num_traits::Float;\n\n let x = 3.0;\n let y = -3.0;\n\n let abs_difference_x = (x.abs_sub(1.0) - 2.0).abs();\n let abs_difference_y = (y.abs_sub(1.0) - 0.0).abs();\n\n assert!(abs_difference_x < 1e-10);\n assert!(abs_difference_y < 1e-10);\n ```\n"},{"kind":"Method","id":{"krate":0,"index":174},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/float.rs","byte_start":38933,"byte_end":38937,"line_start":620,"line_end":620,"column_start":8,"column_end":12},"name":"cbrt","qualname":"::float::Float::cbrt","value":"fn (self) -> Self","parent":{"krate":0,"index":93},"children":[],"decl_id":null,"docs":" Take the cubic root of a number.\n\n ```\n use num_traits::Float;\n\n let x = 8.0;\n\n // x^(1/3) - 2 == 0\n let abs_difference = (x.cbrt() - 2.0).abs();\n\n assert!(abs_difference < 1e-10);\n ```\n"},{"kind":"Method","id":{"krate":0,"index":176},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/float.rs","byte_start":39355,"byte_end":39360,"line_start":636,"line_end":636,"column_start":8,"column_end":13},"name":"hypot","qualname":"::float::Float::hypot","value":"fn (self, other: Self) -> Self","parent":{"krate":0,"index":93},"children":[],"decl_id":null,"docs":" Calculate the length of the hypotenuse of a right-angle triangle given\n legs of length `x` and `y`.\n\n ```\n use num_traits::Float;\n\n let x = 2.0;\n let y = 3.0;\n\n // sqrt(x^2 + y^2)\n let abs_difference = (x.hypot(y) - (x.powi(2) + y.powi(2)).sqrt()).abs();\n\n assert!(abs_difference < 1e-10);\n ```\n"},{"kind":"Method","id":{"krate":0,"index":179},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/float.rs","byte_start":39688,"byte_end":39691,"line_start":650,"line_end":650,"column_start":8,"column_end":11},"name":"sin","qualname":"::float::Float::sin","value":"fn (self) -> Self","parent":{"krate":0,"index":93},"children":[],"decl_id":null,"docs":" Computes the sine of a number (in radians).\n\n ```\n use num_traits::Float;\n use std::f64;\n\n let x = f64::consts::PI/2.0;\n\n let abs_difference = (x.sin() - 1.0).abs();\n\n assert!(abs_difference < 1e-10);\n ```\n"},{"kind":"Method","id":{"krate":0,"index":181},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/float.rs","byte_start":40008,"byte_end":40011,"line_start":664,"line_end":664,"column_start":8,"column_end":11},"name":"cos","qualname":"::float::Float::cos","value":"fn (self) -> Self","parent":{"krate":0,"index":93},"children":[],"decl_id":null,"docs":" Computes the cosine of a number (in radians).\n\n ```\n use num_traits::Float;\n use std::f64;\n\n let x = 2.0*f64::consts::PI;\n\n let abs_difference = (x.cos() - 1.0).abs();\n\n assert!(abs_difference < 1e-10);\n ```\n"},{"kind":"Method","id":{"krate":0,"index":183},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/float.rs","byte_start":40321,"byte_end":40324,"line_start":677,"line_end":677,"column_start":8,"column_end":11},"name":"tan","qualname":"::float::Float::tan","value":"fn (self) -> Self","parent":{"krate":0,"index":93},"children":[],"decl_id":null,"docs":" Computes the tangent of a number (in radians).\n\n ```\n use num_traits::Float;\n use std::f64;\n\n let x = f64::consts::PI/4.0;\n let abs_difference = (x.tan() - 1.0).abs();\n\n assert!(abs_difference < 1e-14);\n ```\n"},{"kind":"Method","id":{"krate":0,"index":185},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/float.rs","byte_start":40804,"byte_end":40808,"line_start":694,"line_end":694,"column_start":8,"column_end":12},"name":"asin","qualname":"::float::Float::asin","value":"fn (self) -> Self","parent":{"krate":0,"index":93},"children":[],"decl_id":null,"docs":" Computes the arcsine of a number. Return value is in radians in\n the range [-pi/2, pi/2] or NaN if the number is outside the range\n [-1, 1].\n\n ```\n use num_traits::Float;\n use std::f64;\n\n let f = f64::consts::PI / 2.0;\n\n // asin(sin(pi/2))\n let abs_difference = (f.sin().asin() - f64::consts::PI / 2.0).abs();\n\n assert!(abs_difference < 1e-10);\n ```\n"},{"kind":"Method","id":{"krate":0,"index":187},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/float.rs","byte_start":41284,"byte_end":41288,"line_start":711,"line_end":711,"column_start":8,"column_end":12},"name":"acos","qualname":"::float::Float::acos","value":"fn (self) -> Self","parent":{"krate":0,"index":93},"children":[],"decl_id":null,"docs":" Computes the arccosine of a number. Return value is in radians in\n the range [0, pi] or NaN if the number is outside the range\n [-1, 1].\n\n ```\n use num_traits::Float;\n use std::f64;\n\n let f = f64::consts::PI / 4.0;\n\n // acos(cos(pi/4))\n let abs_difference = (f.cos().acos() - f64::consts::PI / 4.0).abs();\n\n assert!(abs_difference < 1e-10);\n ```\n"},{"kind":"Method","id":{"krate":0,"index":189},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/float.rs","byte_start":41652,"byte_end":41656,"line_start":726,"line_end":726,"column_start":8,"column_end":12},"name":"atan","qualname":"::float::Float::atan","value":"fn (self) -> Self","parent":{"krate":0,"index":93},"children":[],"decl_id":null,"docs":" Computes the arctangent of a number. Return value is in radians in the\n range [-pi/2, pi/2];\n\n ```\n use num_traits::Float;\n\n let f = 1.0;\n\n // atan(tan(1))\n let abs_difference = (f.tan().atan() - 1.0).abs();\n\n assert!(abs_difference < 1e-10);\n ```\n"},{"kind":"Method","id":{"krate":0,"index":191},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/float.rs","byte_start":42537,"byte_end":42542,"line_start":755,"line_end":755,"column_start":8,"column_end":13},"name":"atan2","qualname":"::float::Float::atan2","value":"fn (self, other: Self) -> Self","parent":{"krate":0,"index":93},"children":[],"decl_id":null,"docs":" Computes the four quadrant arctangent of `self` (`y`) and `other` (`x`).\n\n * `x = 0`, `y = 0`: `0`\n * `x >= 0`: `arctan(y/x)` -> `[-pi/2, pi/2]`\n * `y >= 0`: `arctan(y/x) + pi` -> `(pi/2, pi]`\n * `y < 0`: `arctan(y/x) - pi` -> `(-pi, -pi/2)`\n\n ```\n use num_traits::Float;\n use std::f64;\n\n let pi = f64::consts::PI;\n // All angles from horizontal right (+x)\n // 45 deg counter-clockwise\n let x1 = 3.0;\n let y1 = -3.0;\n\n // 135 deg clockwise\n let x2 = -3.0;\n let y2 = 3.0;\n\n let abs_difference_1 = (y1.atan2(x1) - (-pi/4.0)).abs();\n let abs_difference_2 = (y2.atan2(x2) - 3.0*pi/4.0).abs();\n\n assert!(abs_difference_1 < 1e-10);\n assert!(abs_difference_2 < 1e-10);\n ```\n"},{"kind":"Method","id":{"krate":0,"index":194},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/float.rs","byte_start":43056,"byte_end":43063,"line_start":773,"line_end":773,"column_start":8,"column_end":15},"name":"sin_cos","qualname":"::float::Float::sin_cos","value":"fn (self) -> (Self, Self)","parent":{"krate":0,"index":93},"children":[],"decl_id":null,"docs":" Simultaneously computes the sine and cosine of the number, `x`. Returns\n `(sin(x), cos(x))`.\n\n ```\n use num_traits::Float;\n use std::f64;\n\n let x = f64::consts::PI/4.0;\n let f = x.sin_cos();\n\n let abs_difference_0 = (f.0 - x.sin()).abs();\n let abs_difference_1 = (f.1 - x.cos()).abs();\n\n assert!(abs_difference_0 < 1e-10);\n assert!(abs_difference_0 < 1e-10);\n ```\n"},{"kind":"Method","id":{"krate":0,"index":196},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/float.rs","byte_start":43431,"byte_end":43437,"line_start":788,"line_end":788,"column_start":8,"column_end":14},"name":"exp_m1","qualname":"::float::Float::exp_m1","value":"fn (self) -> Self","parent":{"krate":0,"index":93},"children":[],"decl_id":null,"docs":" Returns `e^(self) - 1` in a way that is accurate even if the\n number is close to zero.\n\n ```\n use num_traits::Float;\n\n let x = 7.0;\n\n // e^(ln(7)) - 1\n let abs_difference = (x.ln().exp_m1() - 6.0).abs();\n\n assert!(abs_difference < 1e-10);\n ```\n"},{"kind":"Method","id":{"krate":0,"index":198},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/float.rs","byte_start":43864,"byte_end":43869,"line_start":804,"line_end":804,"column_start":8,"column_end":13},"name":"ln_1p","qualname":"::float::Float::ln_1p","value":"fn (self) -> Self","parent":{"krate":0,"index":93},"children":[],"decl_id":null,"docs":" Returns `ln(1+n)` (natural logarithm) more accurately than if\n the operations were performed separately.\n\n ```\n use num_traits::Float;\n use std::f64;\n\n let x = f64::consts::E - 1.0;\n\n // ln(1 + (e - 1)) == ln(e) == 1\n let abs_difference = (x.ln_1p() - 1.0).abs();\n\n assert!(abs_difference < 1e-10);\n ```\n"},{"kind":"Method","id":{"krate":0,"index":200},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/float.rs","byte_start":44289,"byte_end":44293,"line_start":822,"line_end":822,"column_start":8,"column_end":12},"name":"sinh","qualname":"::float::Float::sinh","value":"fn (self) -> Self","parent":{"krate":0,"index":93},"children":[],"decl_id":null,"docs":" Hyperbolic sine function.\n\n ```\n use num_traits::Float;\n use std::f64;\n\n let e = f64::consts::E;\n let x = 1.0;\n\n let f = x.sinh();\n // Solving sinh() at 1 gives `(e^2-1)/(2e)`\n let g = (e*e - 1.0)/(2.0*e);\n let abs_difference = (f - g).abs();\n\n assert!(abs_difference < 1e-10);\n ```\n"},{"kind":"Method","id":{"krate":0,"index":202},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/float.rs","byte_start":44729,"byte_end":44733,"line_start":840,"line_end":840,"column_start":8,"column_end":12},"name":"cosh","qualname":"::float::Float::cosh","value":"fn (self) -> Self","parent":{"krate":0,"index":93},"children":[],"decl_id":null,"docs":" Hyperbolic cosine function.\n\n ```\n use num_traits::Float;\n use std::f64;\n\n let e = f64::consts::E;\n let x = 1.0;\n let f = x.cosh();\n // Solving cosh() at 1 gives this result\n let g = (e*e + 1.0)/(2.0*e);\n let abs_difference = (f - g).abs();\n\n // Same result\n assert!(abs_difference < 1.0e-10);\n ```\n"},{"kind":"Method","id":{"krate":0,"index":204},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/float.rs","byte_start":45189,"byte_end":45193,"line_start":858,"line_end":858,"column_start":8,"column_end":12},"name":"tanh","qualname":"::float::Float::tanh","value":"fn (self) -> Self","parent":{"krate":0,"index":93},"children":[],"decl_id":null,"docs":" Hyperbolic tangent function.\n\n ```\n use num_traits::Float;\n use std::f64;\n\n let e = f64::consts::E;\n let x = 1.0;\n\n let f = x.tanh();\n // Solving tanh() at 1 gives `(1 - e^(-2))/(1 + e^(-2))`\n let g = (1.0 - e.powi(-2))/(1.0 + e.powi(-2));\n let abs_difference = (f - g).abs();\n\n assert!(abs_difference < 1.0e-10);\n ```\n"},{"kind":"Method","id":{"krate":0,"index":206},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/float.rs","byte_start":45488,"byte_end":45493,"line_start":872,"line_end":872,"column_start":8,"column_end":13},"name":"asinh","qualname":"::float::Float::asinh","value":"fn (self) -> Self","parent":{"krate":0,"index":93},"children":[],"decl_id":null,"docs":" Inverse hyperbolic sine function.\n\n ```\n use num_traits::Float;\n\n let x = 1.0;\n let f = x.sinh().asinh();\n\n let abs_difference = (f - x).abs();\n\n assert!(abs_difference < 1.0e-10);\n ```\n"},{"kind":"Method","id":{"krate":0,"index":208},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/float.rs","byte_start":45790,"byte_end":45795,"line_start":886,"line_end":886,"column_start":8,"column_end":13},"name":"acosh","qualname":"::float::Float::acosh","value":"fn (self) -> Self","parent":{"krate":0,"index":93},"children":[],"decl_id":null,"docs":" Inverse hyperbolic cosine function.\n\n ```\n use num_traits::Float;\n\n let x = 1.0;\n let f = x.cosh().acosh();\n\n let abs_difference = (f - x).abs();\n\n assert!(abs_difference < 1.0e-10);\n ```\n"},{"kind":"Method","id":{"krate":0,"index":210},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/float.rs","byte_start":46126,"byte_end":46131,"line_start":901,"line_end":901,"column_start":8,"column_end":13},"name":"atanh","qualname":"::float::Float::atanh","value":"fn (self) -> Self","parent":{"krate":0,"index":93},"children":[],"decl_id":null,"docs":" Inverse hyperbolic tangent function.\n\n ```\n use num_traits::Float;\n use std::f64;\n\n let e = f64::consts::E;\n let f = e.tanh().atanh();\n\n let abs_difference = (f - e).abs();\n\n assert!(abs_difference < 1.0e-10);\n ```\n"},{"kind":"Method","id":{"krate":0,"index":212},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/float.rs","byte_start":46980,"byte_end":46994,"line_start":925,"line_end":925,"column_start":8,"column_end":22},"name":"integer_decode","qualname":"::float::Float::integer_decode","value":"fn (self) -> (u64, i16, i8)","parent":{"krate":0,"index":93},"children":[],"decl_id":null,"docs":" Returns the mantissa, base 2 exponent, and sign as integers, respectively.\n The original number can be recovered by `sign * mantissa * 2 ^ exponent`.\n The floating point encoding is documented in the [Reference][floating-point].\n\n ```\n use num_traits::Float;\n\n let num = 2.0f32;\n\n // (8388608, -22, 1)\n let (mantissa, exponent, sign) = Float::integer_decode(num);\n let sign_f = sign as f32;\n let mantissa_f = mantissa as f32;\n let exponent_f = num.powf(exponent as f32);\n\n // 1 * 8388608 * 2^(-22) == 2\n let abs_difference = (sign_f * mantissa_f * exponent_f - num).abs();\n\n assert!(abs_difference < 1e-10);\n ```\n [floating-point]: ../../../../../reference.html#machine-types\n"},{"kind":"Macro","id":{"krate":4294967295,"index":4294967295},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/float.rs","byte_start":47036,"byte_end":47046,"line_start":928,"line_end":928,"column_start":14,"column_end":24},"name":"float_impl","qualname":"float_impl::11577163099583489115","value":"","parent":null,"children":[],"decl_id":null,"docs":""},{"kind":"Macro","id":{"krate":4294967295,"index":4294967295},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/float.rs","byte_start":54840,"byte_end":54856,"line_start":1263,"line_end":1263,"column_start":14,"column_end":30},"name":"float_const_impl","qualname":"float_const_impl::11962379990334303039","value":"","parent":null,"children":[],"decl_id":null,"docs":""},{"kind":"Mod","id":{"krate":0,"index":226},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/lib.rs","byte_start":940,"byte_end":944,"line_start":30,"line_end":30,"column_start":9,"column_end":13},"name":"cast","qualname":"::cast","value":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/cast.rs","parent":null,"children":[{"krate":0,"index":227},{"krate":0,"index":228},{"krate":0,"index":229},{"krate":0,"index":230},{"krate":0,"index":1362},{"krate":0,"index":1412},{"krate":0,"index":1462},{"krate":0,"index":1512},{"krate":0,"index":1562},{"krate":0,"index":1612},{"krate":0,"index":1652},{"krate":0,"index":1692},{"krate":0,"index":1732},{"krate":0,"index":1772},{"krate":0,"index":1812},{"krate":0,"index":1841},{"krate":0,"index":275},{"krate":0,"index":1870},{"krate":0,"index":1891},{"krate":0,"index":1912},{"krate":0,"index":1933},{"krate":0,"index":1954},{"krate":0,"index":1975},{"krate":0,"index":1996},{"krate":0,"index":2017},{"krate":0,"index":2038},{"krate":0,"index":2059},{"krate":0,"index":2080},{"krate":0,"index":2101},{"krate":0,"index":300},{"krate":0,"index":304},{"krate":0,"index":2122},{"krate":0,"index":2126},{"krate":0,"index":2130},{"krate":0,"index":2134},{"krate":0,"index":2138},{"krate":0,"index":2142},{"krate":0,"index":2146},{"krate":0,"index":2150},{"krate":0,"index":2154},{"krate":0,"index":2158},{"krate":0,"index":2162},{"krate":0,"index":2166}],"decl_id":null,"docs":""},{"kind":"Trait","id":{"krate":0,"index":230},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/cast.rs","byte_start":57167,"byte_end":57178,"line_start":7,"line_end":7,"column_start":11,"column_end":22},"name":"ToPrimitive","qualname":"::cast::ToPrimitive","value":"ToPrimitive","parent":null,"children":[{"krate":0,"index":231},{"krate":0,"index":235},{"krate":0,"index":239},{"krate":0,"index":243},{"krate":0,"index":247},{"krate":0,"index":249},{"krate":0,"index":253},{"krate":0,"index":257},{"krate":0,"index":261},{"krate":0,"index":265},{"krate":0,"index":267},{"krate":0,"index":271}],"decl_id":null,"docs":" A generic trait for converting a value to a number.\n"},{"kind":"Method","id":{"krate":0,"index":231},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/cast.rs","byte_start":57254,"byte_end":57262,"line_start":10,"line_end":10,"column_start":8,"column_end":16},"name":"to_isize","qualname":"::cast::ToPrimitive::to_isize","value":"fn (&self) -> Option<isize>","parent":{"krate":0,"index":230},"children":[],"decl_id":null,"docs":" Converts the value of `self` to an `isize`.\n"},{"kind":"Method","id":{"krate":0,"index":235},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/cast.rs","byte_start":57415,"byte_end":57420,"line_start":16,"line_end":16,"column_start":8,"column_end":13},"name":"to_i8","qualname":"::cast::ToPrimitive::to_i8","value":"fn (&self) -> Option<i8>","parent":{"krate":0,"index":230},"children":[],"decl_id":null,"docs":" Converts the value of `self` to an `i8`.\n"},{"kind":"Method","id":{"krate":0,"index":239},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/cast.rs","byte_start":57568,"byte_end":57574,"line_start":22,"line_end":22,"column_start":8,"column_end":14},"name":"to_i16","qualname":"::cast::ToPrimitive::to_i16","value":"fn (&self) -> Option<i16>","parent":{"krate":0,"index":230},"children":[],"decl_id":null,"docs":" Converts the value of `self` to an `i16`.\n"},{"kind":"Method","id":{"krate":0,"index":243},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/cast.rs","byte_start":57724,"byte_end":57730,"line_start":28,"line_end":28,"column_start":8,"column_end":14},"name":"to_i32","qualname":"::cast::ToPrimitive::to_i32","value":"fn (&self) -> Option<i32>","parent":{"krate":0,"index":230},"children":[],"decl_id":null,"docs":" Converts the value of `self` to an `i32`.\n"},{"kind":"Method","id":{"krate":0,"index":247},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/cast.rs","byte_start":57866,"byte_end":57872,"line_start":33,"line_end":33,"column_start":8,"column_end":14},"name":"to_i64","qualname":"::cast::ToPrimitive::to_i64","value":"fn (&self) -> Option<i64>","parent":{"krate":0,"index":230},"children":[],"decl_id":null,"docs":" Converts the value of `self` to an `i64`.\n"},{"kind":"Method","id":{"krate":0,"index":249},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/cast.rs","byte_start":57969,"byte_end":57977,"line_start":37,"line_end":37,"column_start":8,"column_end":16},"name":"to_usize","qualname":"::cast::ToPrimitive::to_usize","value":"fn (&self) -> Option<usize>","parent":{"krate":0,"index":230},"children":[],"decl_id":null,"docs":" Converts the value of `self` to a `usize`.\n"},{"kind":"Method","id":{"krate":0,"index":253},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/cast.rs","byte_start":58130,"byte_end":58135,"line_start":43,"line_end":43,"column_start":8,"column_end":13},"name":"to_u8","qualname":"::cast::ToPrimitive::to_u8","value":"fn (&self) -> Option<u8>","parent":{"krate":0,"index":230},"children":[],"decl_id":null,"docs":" Converts the value of `self` to an `u8`.\n"},{"kind":"Method","id":{"krate":0,"index":257},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/cast.rs","byte_start":58283,"byte_end":58289,"line_start":49,"line_end":49,"column_start":8,"column_end":14},"name":"to_u16","qualname":"::cast::ToPrimitive::to_u16","value":"fn (&self) -> Option<u16>","parent":{"krate":0,"index":230},"children":[],"decl_id":null,"docs":" Converts the value of `self` to an `u16`.\n"},{"kind":"Method","id":{"krate":0,"index":261},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/cast.rs","byte_start":58439,"byte_end":58445,"line_start":55,"line_end":55,"column_start":8,"column_end":14},"name":"to_u32","qualname":"::cast::ToPrimitive::to_u32","value":"fn (&self) -> Option<u32>","parent":{"krate":0,"index":230},"children":[],"decl_id":null,"docs":" Converts the value of `self` to an `u32`.\n"},{"kind":"Method","id":{"krate":0,"index":265},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/cast.rs","byte_start":58595,"byte_end":58601,"line_start":61,"line_end":61,"column_start":8,"column_end":14},"name":"to_u64","qualname":"::cast::ToPrimitive::to_u64","value":"fn (&self) -> Option<u64>","parent":{"krate":0,"index":230},"children":[],"decl_id":null,"docs":" Converts the value of `self` to an `u64`.\n"},{"kind":"Method","id":{"krate":0,"index":267},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/cast.rs","byte_start":58697,"byte_end":58703,"line_start":65,"line_end":65,"column_start":8,"column_end":14},"name":"to_f32","qualname":"::cast::ToPrimitive::to_f32","value":"fn (&self) -> Option<f32>","parent":{"krate":0,"index":230},"children":[],"decl_id":null,"docs":" Converts the value of `self` to an `f32`.\n"},{"kind":"Method","id":{"krate":0,"index":271},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/cast.rs","byte_start":58853,"byte_end":58859,"line_start":71,"line_end":71,"column_start":8,"column_end":14},"name":"to_f64","qualname":"::cast::ToPrimitive::to_f64","value":"fn (&self) -> Option<f64>","parent":{"krate":0,"index":230},"children":[],"decl_id":null,"docs":" Converts the value of `self` to an `f64`.\n"},{"kind":"Macro","id":{"krate":4294967295,"index":4294967295},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/cast.rs","byte_start":59904,"byte_end":59925,"line_start":109,"line_end":109,"column_start":14,"column_end":35},"name":"impl_to_primitive_int","qualname":"impl_to_primitive_int::15220233196650753909","value":"","parent":null,"children":[],"decl_id":null,"docs":""},{"kind":"Macro","id":{"krate":4294967295,"index":4294967295},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/cast.rs","byte_start":62343,"byte_end":62365,"line_start":179,"line_end":179,"column_start":14,"column_end":36},"name":"impl_to_primitive_uint","qualname":"impl_to_primitive_uint::7105200447359336225","value":"","parent":null,"children":[],"decl_id":null,"docs":""},{"kind":"Macro","id":{"krate":4294967295,"index":4294967295},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/cast.rs","byte_start":64565,"byte_end":64588,"line_start":238,"line_end":238,"column_start":14,"column_end":37},"name":"impl_to_primitive_float","qualname":"impl_to_primitive_float::7958274628691780432","value":"","parent":null,"children":[],"decl_id":null,"docs":""},{"kind":"Trait","id":{"krate":0,"index":275},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/cast.rs","byte_start":65931,"byte_end":65944,"line_start":275,"line_end":275,"column_start":11,"column_end":24},"name":"FromPrimitive","qualname":"::cast::FromPrimitive","value":"FromPrimitive:  Sized","parent":null,"children":[{"krate":0,"index":276},{"krate":0,"index":278},{"krate":0,"index":280},{"krate":0,"index":282},{"krate":0,"index":284},{"krate":0,"index":286},{"krate":0,"index":288},{"krate":0,"index":290},{"krate":0,"index":292},{"krate":0,"index":294},{"krate":0,"index":296},{"krate":0,"index":298}],"decl_id":null,"docs":" A generic trait for converting a number to a value.\n"},{"kind":"Method","id":{"krate":0,"index":276},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/cast.rs","byte_start":66126,"byte_end":66136,"line_start":279,"line_end":279,"column_start":8,"column_end":18},"name":"from_isize","qualname":"::cast::FromPrimitive::from_isize","value":"fn (n: isize) -> Option<Self>","parent":{"krate":0,"index":275},"children":[],"decl_id":null,"docs":" Convert an `isize` to return an optional value of this type. If the\n value cannot be represented by this value, the `None` is returned.\n"},{"kind":"Method","id":{"krate":0,"index":278},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/cast.rs","byte_start":66382,"byte_end":66389,"line_start":286,"line_end":286,"column_start":8,"column_end":15},"name":"from_i8","qualname":"::cast::FromPrimitive::from_i8","value":"fn (n: i8) -> Option<Self>","parent":{"krate":0,"index":275},"children":[],"decl_id":null,"docs":" Convert an `i8` to return an optional value of this type. If the\n type cannot be represented by this value, the `None` is returned.\n"},{"kind":"Method","id":{"krate":0,"index":280},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/cast.rs","byte_start":66633,"byte_end":66641,"line_start":293,"line_end":293,"column_start":8,"column_end":16},"name":"from_i16","qualname":"::cast::FromPrimitive::from_i16","value":"fn (n: i16) -> Option<Self>","parent":{"krate":0,"index":275},"children":[],"decl_id":null,"docs":" Convert an `i16` to return an optional value of this type. If the\n type cannot be represented by this value, the `None` is returned.\n"},{"kind":"Method","id":{"krate":0,"index":282},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/cast.rs","byte_start":66886,"byte_end":66894,"line_start":300,"line_end":300,"column_start":8,"column_end":16},"name":"from_i32","qualname":"::cast::FromPrimitive::from_i32","value":"fn (n: i32) -> Option<Self>","parent":{"krate":0,"index":275},"children":[],"decl_id":null,"docs":" Convert an `i32` to return an optional value of this type. If the\n type cannot be represented by this value, the `None` is returned.\n"},{"kind":"Method","id":{"krate":0,"index":284},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/cast.rs","byte_start":67125,"byte_end":67133,"line_start":306,"line_end":306,"column_start":8,"column_end":16},"name":"from_i64","qualname":"::cast::FromPrimitive::from_i64","value":"fn (n: i64) -> Option<Self>","parent":{"krate":0,"index":275},"children":[],"decl_id":null,"docs":" Convert an `i64` to return an optional value of this type. If the\n type cannot be represented by this value, the `None` is returned.\n"},{"kind":"Method","id":{"krate":0,"index":286},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/cast.rs","byte_start":67330,"byte_end":67340,"line_start":311,"line_end":311,"column_start":8,"column_end":18},"name":"from_usize","qualname":"::cast::FromPrimitive::from_usize","value":"fn (n: usize) -> Option<Self>","parent":{"krate":0,"index":275},"children":[],"decl_id":null,"docs":" Convert a `usize` to return an optional value of this type. If the\n type cannot be represented by this value, the `None` is returned.\n"},{"kind":"Method","id":{"krate":0,"index":288},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/cast.rs","byte_start":67586,"byte_end":67593,"line_start":318,"line_end":318,"column_start":8,"column_end":15},"name":"from_u8","qualname":"::cast::FromPrimitive::from_u8","value":"fn (n: u8) -> Option<Self>","parent":{"krate":0,"index":275},"children":[],"decl_id":null,"docs":" Convert an `u8` to return an optional value of this type. If the\n type cannot be represented by this value, the `None` is returned.\n"},{"kind":"Method","id":{"krate":0,"index":290},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/cast.rs","byte_start":67837,"byte_end":67845,"line_start":325,"line_end":325,"column_start":8,"column_end":16},"name":"from_u16","qualname":"::cast::FromPrimitive::from_u16","value":"fn (n: u16) -> Option<Self>","parent":{"krate":0,"index":275},"children":[],"decl_id":null,"docs":" Convert an `u16` to return an optional value of this type. If the\n type cannot be represented by this value, the `None` is returned.\n"},{"kind":"Method","id":{"krate":0,"index":292},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/cast.rs","byte_start":68090,"byte_end":68098,"line_start":332,"line_end":332,"column_start":8,"column_end":16},"name":"from_u32","qualname":"::cast::FromPrimitive::from_u32","value":"fn (n: u32) -> Option<Self>","parent":{"krate":0,"index":275},"children":[],"decl_id":null,"docs":" Convert an `u32` to return an optional value of this type. If the\n type cannot be represented by this value, the `None` is returned.\n"},{"kind":"Method","id":{"krate":0,"index":294},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/cast.rs","byte_start":68329,"byte_end":68337,"line_start":338,"line_end":338,"column_start":8,"column_end":16},"name":"from_u64","qualname":"::cast::FromPrimitive::from_u64","value":"fn (n: u64) -> Option<Self>","parent":{"krate":0,"index":275},"children":[],"decl_id":null,"docs":" Convert an `u64` to return an optional value of this type. If the\n type cannot be represented by this value, the `None` is returned.\n"},{"kind":"Method","id":{"krate":0,"index":296},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/cast.rs","byte_start":68532,"byte_end":68540,"line_start":343,"line_end":343,"column_start":8,"column_end":16},"name":"from_f32","qualname":"::cast::FromPrimitive::from_f32","value":"fn (n: f32) -> Option<Self>","parent":{"krate":0,"index":275},"children":[],"decl_id":null,"docs":" Convert a `f32` to return an optional value of this type. If the\n type cannot be represented by this value, the `None` is returned.\n"},{"kind":"Method","id":{"krate":0,"index":298},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/cast.rs","byte_start":68784,"byte_end":68792,"line_start":350,"line_end":350,"column_start":8,"column_end":16},"name":"from_f64","qualname":"::cast::FromPrimitive::from_f64","value":"fn (n: f64) -> Option<Self>","parent":{"krate":0,"index":275},"children":[],"decl_id":null,"docs":" Convert a `f64` to return an optional value of this type. If the\n type cannot be represented by this value, the `None` is returned.\n"},{"kind":"Macro","id":{"krate":4294967295,"index":4294967295},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/cast.rs","byte_start":68883,"byte_end":68902,"line_start":355,"line_end":355,"column_start":14,"column_end":33},"name":"impl_from_primitive","qualname":"impl_from_primitive::16258176166979202423","value":"","parent":null,"children":[],"decl_id":null,"docs":""},{"kind":"Function","id":{"krate":0,"index":300},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/cast.rs","byte_start":70388,"byte_end":70392,"line_start":399,"line_end":399,"column_start":8,"column_end":12},"name":"cast","qualname":"::cast::cast","value":"fn <T, U> (n: T) -> Option<U>","parent":null,"children":[],"decl_id":null,"docs":" Cast from one machine scalar to another.\n\n # Examples\n\n ```\n # use num_traits as num;\n let twenty: f32 = num::cast(0x14).unwrap();\n assert_eq!(twenty, 20f32);\n ```\n\n"},{"kind":"Trait","id":{"krate":0,"index":304},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/cast.rs","byte_start":70526,"byte_end":70533,"line_start":404,"line_end":404,"column_start":11,"column_end":18},"name":"NumCast","qualname":"::cast::NumCast","value":"NumCast:  Sized + ToPrimitive","parent":null,"children":[{"krate":0,"index":305}],"decl_id":null,"docs":" An interface for casting between machine scalars.\n"},{"kind":"Method","id":{"krate":0,"index":305},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/cast.rs","byte_start":70684,"byte_end":70688,"line_start":407,"line_end":407,"column_start":8,"column_end":12},"name":"from","qualname":"::cast::NumCast::from","value":"fn <T> (n: T) -> Option<Self>","parent":{"krate":0,"index":304},"children":[],"decl_id":null,"docs":" Creates a number from another value that can be converted into\n a primitive via the `ToPrimitive` trait.\n"},{"kind":"Macro","id":{"krate":4294967295,"index":4294967295},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/cast.rs","byte_start":70744,"byte_end":70757,"line_start":410,"line_end":410,"column_start":14,"column_end":27},"name":"impl_num_cast","qualname":"impl_num_cast::18104433705606786691","value":"","parent":null,"children":[],"decl_id":null,"docs":""},{"kind":"Mod","id":{"krate":0,"index":308},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/lib.rs","byte_start":954,"byte_end":957,"line_start":31,"line_end":31,"column_start":9,"column_end":12},"name":"int","qualname":"::int","value":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/int.rs","parent":null,"children":[{"krate":0,"index":309},{"krate":0,"index":310},{"krate":0,"index":311},{"krate":0,"index":312},{"krate":0,"index":313},{"krate":0,"index":314},{"krate":0,"index":2170},{"krate":0,"index":2210},{"krate":0,"index":2250},{"krate":0,"index":2290},{"krate":0,"index":2330},{"krate":0,"index":2370},{"krate":0,"index":2410},{"krate":0,"index":2450},{"krate":0,"index":2490},{"krate":0,"index":2530}],"decl_id":null,"docs":""},{"kind":"Trait","id":{"krate":0,"index":314},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/int.rs","byte_start":72135,"byte_end":72142,"line_start":8,"line_end":8,"column_start":11,"column_end":18},"name":"PrimInt","qualname":"::int::PrimInt","value":"PrimInt:  Sized + Copy + Num + NumCast + Bounded + PartialOrd + Ord + Eq + Not<Output =\nSelf> + BitAnd<Output = Self> + BitOr<Output = Self> + BitXor<Output = Self> +\nShl<usize, Output = Self> + Shr<usize, Output = Self> + CheckedAdd<Output =\nSelf> + CheckedSub<Output = Self> + CheckedMul<Output = Self> +\nCheckedDiv<Output = Self> + Saturating","parent":null,"children":[{"krate":0,"index":315},{"krate":0,"index":317},{"krate":0,"index":319},{"krate":0,"index":321},{"krate":0,"index":323},{"krate":0,"index":326},{"krate":0,"index":329},{"krate":0,"index":332},{"krate":0,"index":335},{"krate":0,"index":338},{"krate":0,"index":341},{"krate":0,"index":343},{"krate":0,"index":345},{"krate":0,"index":347},{"krate":0,"index":349},{"krate":0,"index":351}],"decl_id":null,"docs":""},{"kind":"Method","id":{"krate":0,"index":315},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/int.rs","byte_start":72786,"byte_end":72796,"line_start":37,"line_end":37,"column_start":8,"column_end":18},"name":"count_ones","qualname":"::int::PrimInt::count_ones","value":"fn (self) -> u32","parent":{"krate":0,"index":314},"children":[],"decl_id":null,"docs":" Returns the number of ones in the binary representation of `self`.\n\n # Examples\n\n ```\n use num_traits::PrimInt;\n\n let n = 0b01001100u8;\n\n assert_eq!(n.count_ones(), 3);\n ```\n"},{"kind":"Method","id":{"krate":0,"index":317},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/int.rs","byte_start":73073,"byte_end":73084,"line_start":50,"line_end":50,"column_start":8,"column_end":19},"name":"count_zeros","qualname":"::int::PrimInt::count_zeros","value":"fn (self) -> u32","parent":{"krate":0,"index":314},"children":[],"decl_id":null,"docs":" Returns the number of zeros in the binary representation of `self`.\n\n # Examples\n\n ```\n use num_traits::PrimInt;\n\n let n = 0b01001100u8;\n\n assert_eq!(n.count_zeros(), 5);\n ```\n"},{"kind":"Method","id":{"krate":0,"index":319},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/int.rs","byte_start":73380,"byte_end":73393,"line_start":64,"line_end":64,"column_start":8,"column_end":21},"name":"leading_zeros","qualname":"::int::PrimInt::leading_zeros","value":"fn (self) -> u32","parent":{"krate":0,"index":314},"children":[],"decl_id":null,"docs":" Returns the number of leading zeros in the binary representation\n of `self`.\n\n # Examples\n\n ```\n use num_traits::PrimInt;\n\n let n = 0b0101000u16;\n\n assert_eq!(n.leading_zeros(), 10);\n ```\n"},{"kind":"Method","id":{"krate":0,"index":321},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/int.rs","byte_start":73690,"byte_end":73704,"line_start":78,"line_end":78,"column_start":8,"column_end":22},"name":"trailing_zeros","qualname":"::int::PrimInt::trailing_zeros","value":"fn (self) -> u32","parent":{"krate":0,"index":314},"children":[],"decl_id":null,"docs":" Returns the number of trailing zeros in the binary representation\n of `self`.\n\n # Examples\n\n ```\n use num_traits::PrimInt;\n\n let n = 0b0101000u16;\n\n assert_eq!(n.trailing_zeros(), 3);\n ```\n"},{"kind":"Method","id":{"krate":0,"index":323},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/int.rs","byte_start":74099,"byte_end":74110,"line_start":93,"line_end":93,"column_start":8,"column_end":19},"name":"rotate_left","qualname":"::int::PrimInt::rotate_left","value":"fn (self, n: u32) -> Self","parent":{"krate":0,"index":314},"children":[],"decl_id":null,"docs":" Shifts the bits to the left by a specified amount amount, `n`, wrapping\n the truncated bits to the end of the resulting integer.\n\n # Examples\n\n ```\n use num_traits::PrimInt;\n\n let n = 0x0123456789ABCDEFu64;\n let m = 0x3456789ABCDEF012u64;\n\n assert_eq!(n.rotate_left(12), m);\n ```\n"},{"kind":"Method","id":{"krate":0,"index":326},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/int.rs","byte_start":74522,"byte_end":74534,"line_start":108,"line_end":108,"column_start":8,"column_end":20},"name":"rotate_right","qualname":"::int::PrimInt::rotate_right","value":"fn (self, n: u32) -> Self","parent":{"krate":0,"index":314},"children":[],"decl_id":null,"docs":" Shifts the bits to the right by a specified amount amount, `n`, wrapping\n the truncated bits to the beginning of the resulting integer.\n\n # Examples\n\n ```\n use num_traits::PrimInt;\n\n let n = 0x0123456789ABCDEFu64;\n let m = 0xDEF0123456789ABCu64;\n\n assert_eq!(n.rotate_right(12), m);\n ```\n"},{"kind":"Method","id":{"krate":0,"index":329},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/int.rs","byte_start":74977,"byte_end":74987,"line_start":125,"line_end":125,"column_start":8,"column_end":18},"name":"signed_shl","qualname":"::int::PrimInt::signed_shl","value":"fn (self, n: u32) -> Self","parent":{"krate":0,"index":314},"children":[],"decl_id":null,"docs":" Shifts the bits to the left by a specified amount amount, `n`, filling\n zeros in the least significant bits.\n\n This is bitwise equivalent to signed `Shl`.\n\n # Examples\n\n ```\n use num_traits::PrimInt;\n\n let n = 0x0123456789ABCDEFu64;\n let m = 0x3456789ABCDEF000u64;\n\n assert_eq!(n.signed_shl(12), m);\n ```\n"},{"kind":"Method","id":{"krate":0,"index":332},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/int.rs","byte_start":75463,"byte_end":75473,"line_start":142,"line_end":142,"column_start":8,"column_end":18},"name":"signed_shr","qualname":"::int::PrimInt::signed_shr","value":"fn (self, n: u32) -> Self","parent":{"krate":0,"index":314},"children":[],"decl_id":null,"docs":" Shifts the bits to the right by a specified amount amount, `n`, copying\n the \"sign bit\" in the most significant bits even for unsigned types.\n\n This is bitwise equivalent to signed `Shr`.\n\n # Examples\n\n ```\n use num_traits::PrimInt;\n\n let n = 0xFEDCBA9876543210u64;\n let m = 0xFFFFEDCBA9876543u64;\n\n assert_eq!(n.signed_shr(12), m);\n ```\n"},{"kind":"Method","id":{"krate":0,"index":335},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/int.rs","byte_start":75920,"byte_end":75932,"line_start":159,"line_end":159,"column_start":8,"column_end":20},"name":"unsigned_shl","qualname":"::int::PrimInt::unsigned_shl","value":"fn (self, n: u32) -> Self","parent":{"krate":0,"index":314},"children":[],"decl_id":null,"docs":" Shifts the bits to the left by a specified amount amount, `n`, filling\n zeros in the least significant bits.\n\n This is bitwise equivalent to unsigned `Shl`.\n\n # Examples\n\n ```\n use num_traits::PrimInt;\n\n let n = 0x0123456789ABCDEFi64;\n let m = 0x3456789ABCDEF000i64;\n\n assert_eq!(n.unsigned_shl(12), m);\n ```\n"},{"kind":"Method","id":{"krate":0,"index":338},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/int.rs","byte_start":76379,"byte_end":76391,"line_start":176,"line_end":176,"column_start":8,"column_end":20},"name":"unsigned_shr","qualname":"::int::PrimInt::unsigned_shr","value":"fn (self, n: u32) -> Self","parent":{"krate":0,"index":314},"children":[],"decl_id":null,"docs":" Shifts the bits to the right by a specified amount amount, `n`, filling\n zeros in the most significant bits.\n\n This is bitwise equivalent to unsigned `Shr`.\n\n # Examples\n\n ```\n use num_traits::PrimInt;\n\n let n = 0xFEDCBA9876543210i64;\n let m = 0x000FEDCBA9876543i64;\n\n assert_eq!(n.unsigned_shr(12), m);\n ```\n"},{"kind":"Method","id":{"krate":0,"index":341},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/int.rs","byte_start":76696,"byte_end":76706,"line_start":190,"line_end":190,"column_start":8,"column_end":18},"name":"swap_bytes","qualname":"::int::PrimInt::swap_bytes","value":"fn (self) -> Self","parent":{"krate":0,"index":314},"children":[],"decl_id":null,"docs":" Reverses the byte order of the integer.\n\n # Examples\n\n ```\n use num_traits::PrimInt;\n\n let n = 0x0123456789ABCDEFu64;\n let m = 0xEFCDAB8967452301u64;\n\n assert_eq!(n.swap_bytes(), m);\n ```\n"},{"kind":"Method","id":{"krate":0,"index":343},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/int.rs","byte_start":77202,"byte_end":77209,"line_start":209,"line_end":209,"column_start":8,"column_end":15},"name":"from_be","qualname":"::int::PrimInt::from_be","value":"fn (x: Self) -> Self","parent":{"krate":0,"index":314},"children":[],"decl_id":null,"docs":" Convert an integer from big endian to the target's endianness.\n\n On big endian this is a no-op. On little endian the bytes are swapped.\n\n # Examples\n\n ```\n use num_traits::PrimInt;\n\n let n = 0x0123456789ABCDEFu64;\n\n if cfg!(target_endian = \"big\") {\n     assert_eq!(u64::from_be(n), n)\n } else {\n     assert_eq!(u64::from_be(n), n.swap_bytes())\n }\n ```\n"},{"kind":"Method","id":{"krate":0,"index":345},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/int.rs","byte_start":77714,"byte_end":77721,"line_start":228,"line_end":228,"column_start":8,"column_end":15},"name":"from_le","qualname":"::int::PrimInt::from_le","value":"fn (x: Self) -> Self","parent":{"krate":0,"index":314},"children":[],"decl_id":null,"docs":" Convert an integer from little endian to the target's endianness.\n\n On little endian this is a no-op. On big endian the bytes are swapped.\n\n # Examples\n\n ```\n use num_traits::PrimInt;\n\n let n = 0x0123456789ABCDEFu64;\n\n if cfg!(target_endian = \"little\") {\n     assert_eq!(u64::from_le(n), n)\n } else {\n     assert_eq!(u64::from_le(n), n.swap_bytes())\n }\n ```\n"},{"kind":"Method","id":{"krate":0,"index":347},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/int.rs","byte_start":78204,"byte_end":78209,"line_start":247,"line_end":247,"column_start":8,"column_end":13},"name":"to_be","qualname":"::int::PrimInt::to_be","value":"fn (self) -> Self","parent":{"krate":0,"index":314},"children":[],"decl_id":null,"docs":" Convert `self` to big endian from the target's endianness.\n\n On big endian this is a no-op. On little endian the bytes are swapped.\n\n # Examples\n\n ```\n use num_traits::PrimInt;\n\n let n = 0x0123456789ABCDEFu64;\n\n if cfg!(target_endian = \"big\") {\n     assert_eq!(n.to_be(), n)\n } else {\n     assert_eq!(n.to_be(), n.swap_bytes())\n }\n ```\n"},{"kind":"Method","id":{"krate":0,"index":349},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/int.rs","byte_start":78695,"byte_end":78700,"line_start":266,"line_end":266,"column_start":8,"column_end":13},"name":"to_le","qualname":"::int::PrimInt::to_le","value":"fn (self) -> Self","parent":{"krate":0,"index":314},"children":[],"decl_id":null,"docs":" Convert `self` to little endian from the target's endianness.\n\n On little endian this is a no-op. On big endian the bytes are swapped.\n\n # Examples\n\n ```\n use num_traits::PrimInt;\n\n let n = 0x0123456789ABCDEFu64;\n\n if cfg!(target_endian = \"little\") {\n     assert_eq!(n.to_le(), n)\n } else {\n     assert_eq!(n.to_le(), n.swap_bytes())\n }\n ```\n"},{"kind":"Method","id":{"krate":0,"index":351},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/int.rs","byte_start":78938,"byte_end":78941,"line_start":277,"line_end":277,"column_start":8,"column_end":11},"name":"pow","qualname":"::int::PrimInt::pow","value":"fn (self, mut exp: u32) -> Self","parent":{"krate":0,"index":314},"children":[],"decl_id":null,"docs":" Raises self to the power of `exp`, using exponentiation by squaring.\n\n # Examples\n\n ```\n use num_traits::PrimInt;\n\n assert_eq!(2i32.pow(4), 16);\n ```\n"},{"kind":"Macro","id":{"krate":4294967295,"index":4294967295},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/int.rs","byte_start":78987,"byte_end":79000,"line_start":280,"line_end":280,"column_start":14,"column_end":27},"name":"prim_int_impl","qualname":"prim_int_impl::15823915074498801568","value":"","parent":null,"children":[],"decl_id":null,"docs":""},{"kind":"Mod","id":{"krate":0,"index":354},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/lib.rs","byte_start":967,"byte_end":970,"line_start":32,"line_end":32,"column_start":9,"column_end":12},"name":"pow","qualname":"::pow","value":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/pow.rs","parent":null,"children":[{"krate":0,"index":355},{"krate":0,"index":356},{"krate":0,"index":357},{"krate":0,"index":362}],"decl_id":null,"docs":""},{"kind":"Function","id":{"krate":0,"index":357},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/pow.rs","byte_start":81695,"byte_end":81698,"line_start":15,"line_end":15,"column_start":8,"column_end":11},"name":"pow","qualname":"::pow::pow","value":"fn <T> (mut base: T, mut exp: usize) -> T","parent":null,"children":[],"decl_id":null,"docs":" Raises a value to the power of exp, using exponentiation by squaring.\n\n # Example\n\n ```rust\n use num_traits::pow;\n\n assert_eq!(pow(2i8, 4), 16);\n assert_eq!(pow(6u8, 3), 216);\n ```\n"},{"kind":"Function","id":{"krate":0,"index":362},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/pow.rs","byte_start":82495,"byte_end":82506,"line_start":49,"line_end":49,"column_start":8,"column_end":19},"name":"checked_pow","qualname":"::pow::checked_pow","value":"fn <T> (mut base: T, mut exp: usize) -> Option<T>","parent":null,"children":[],"decl_id":null,"docs":" Raises a value to the power of exp, returning `None` if an overflow occurred.\n\n Otherwise same as the `pow` function.\n\n # Example\n\n ```rust\n use num_traits::checked_pow;\n\n assert_eq!(checked_pow(2i8, 4), Some(16));\n assert_eq!(checked_pow(7i8, 8), None);\n assert_eq!(checked_pow(7u32, 8), Some(5_764_801));\n ```\n"},{"kind":"Macro","id":{"krate":4294967295,"index":4294967295},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/pow.rs","byte_start":82640,"byte_end":82645,"line_start":52,"line_end":52,"column_start":18,"column_end":23},"name":"optry","qualname":"optry::11532152135672978818","value":"","parent":null,"children":[],"decl_id":null,"docs":""},{"kind":"Trait","id":{"krate":0,"index":367},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/lib.rs","byte_start":1020,"byte_end":1023,"line_start":35,"line_end":35,"column_start":11,"column_end":14},"name":"Num","qualname":"::Num","value":"Num:  PartialEq + Zero + One + Add<Output = Self> + Sub<Output = Self> + Mul<Output\n= Self> + Div<Output = Self> + Rem<Output = Self>","parent":null,"children":[{"krate":0,"index":368},{"krate":0,"index":369}],"decl_id":null,"docs":" The base trait for numeric types\n"},{"kind":"Method","id":{"krate":0,"index":369},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/lib.rs","byte_start":1244,"byte_end":1258,"line_start":42,"line_end":42,"column_start":8,"column_end":22},"name":"from_str_radix","qualname":"::Num::from_str_radix","value":"fn (str: &str, radix: u32) -> Result<Self, Self::FromStrRadixErr>","parent":{"krate":0,"index":367},"children":[],"decl_id":null,"docs":" Convert from a string and radix <= 36.\n"},{"kind":"Macro","id":{"krate":4294967295,"index":4294967295},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/lib.rs","byte_start":1338,"byte_end":1352,"line_start":45,"line_end":45,"column_start":14,"column_end":28},"name":"int_trait_impl","qualname":"int_trait_impl::8686314807940970274","value":"","parent":null,"children":[],"decl_id":null,"docs":""},{"kind":"Enum","id":{"krate":0,"index":2623},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/lib.rs","byte_start":1820,"byte_end":1834,"line_start":61,"line_end":61,"column_start":10,"column_end":24},"name":"FloatErrorKind","qualname":"::FloatErrorKind","value":"FloatErrorKind::{Empty, Invalid}","parent":null,"children":[{"krate":0,"index":2624},{"krate":0,"index":2625}],"decl_id":null,"docs":""},{"kind":"Tuple","id":{"krate":0,"index":2624},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/lib.rs","byte_start":1841,"byte_end":1846,"line_start":62,"line_end":62,"column_start":5,"column_end":10},"name":"Empty","qualname":"::FloatErrorKind::Empty","value":"FloatErrorKind::Empty","parent":{"krate":0,"index":2623},"children":[],"decl_id":null,"docs":""},{"kind":"Tuple","id":{"krate":0,"index":2625},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/lib.rs","byte_start":1852,"byte_end":1859,"line_start":63,"line_end":63,"column_start":5,"column_end":12},"name":"Invalid","qualname":"::FloatErrorKind::Invalid","value":"FloatErrorKind::Invalid","parent":{"krate":0,"index":2623},"children":[],"decl_id":null,"docs":""},{"kind":"Struct","id":{"krate":0,"index":2632},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/lib.rs","byte_start":2016,"byte_end":2031,"line_start":68,"line_end":68,"column_start":12,"column_end":27},"name":"ParseFloatError","qualname":"::ParseFloatError","value":"ParseFloatError { kind }","parent":null,"children":[{"krate":0,"index":2633}],"decl_id":null,"docs":""},{"kind":"Field","id":{"krate":0,"index":2633},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/lib.rs","byte_start":2042,"byte_end":2046,"line_start":69,"line_end":69,"column_start":9,"column_end":13},"name":"kind","qualname":"::ParseFloatError::kind","value":"","parent":{"krate":0,"index":2632},"children":[],"decl_id":null,"docs":""},{"kind":"Macro","id":{"krate":4294967295,"index":4294967295},"span":{"file_name":"/home/ncameron/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.1.36/src/lib.rs","byte_start":2291,"byte_end":2307,"line_start":75,"line_end":75,"column_start":14,"column_end":30},"name":"float_trait_impl","qualname":"float_trait_impl::1947233244085876018","value":"","parent":null,"children":[],"decl_id":null,"docs":""}],"refs":[],"macro_refs":[]}